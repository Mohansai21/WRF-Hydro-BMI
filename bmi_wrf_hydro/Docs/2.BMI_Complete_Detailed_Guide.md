# The Complete BMI (Basic Model Interface) Guide
## Everything You Need to Know — From Beginner to WRF-Hydro Application

### Written for ML Engineers with Zero Hydrology Background
### Based on Official CSDMS Documentation: bmi.csdms.io | github.com/csdms/bmi

---

## Table of Contents

1. [The Car Analogy — Why BMI Exists](#1-the-car-analogy--why-bmi-exists)
2. [What Exactly IS BMI?](#2-what-exactly-is-bmi)
3. [The Current Status: SCHISM vs WRF-Hydro](#3-the-current-status-schism-vs-wrf-hydro)
4. [The 41 BMI Functions — Complete Deep Dive](#4-the-41-bmi-functions--complete-deep-dive)
   - [Category 1: Model Control Functions](#category-1-model-control-functions-the-lifecycle)
   - [Category 2: Model Information Functions](#category-2-model-information-functions-self-description)
   - [Category 3: Variable Information Functions](#category-3-variable-information-functions-metadata)
   - [Category 4: Time Functions](#category-4-time-functions-temporal-awareness)
   - [Category 5: Getter and Setter Functions](#category-5-getter-and-setter-functions-the-coupling-key)
   - [Category 6: Grid Functions](#category-6-grid-functions-spatial-awareness)
5. [Grid Types in BMI — Complete Guide](#5-grid-types-in-bmi--complete-guide)
6. [CSDMS Standard Names](#6-csdms-standard-names)
7. [BMI Best Practices — Official Wisdom](#7-bmi-best-practices--official-wisdom)
8. [Applying BMI to WRF-Hydro — What Needs to Happen](#8-applying-bmi-to-wrf-hydro--what-needs-to-happen)
9. [SCHISM's BMI — A Reference Example](#9-schisms-bmi--a-reference-example)
10. [The Heat Model Example — BMI in Action](#10-the-heat-model-example--bmi-in-action)
11. [Key References & Links](#11-key-references--links)

---

## 1. The Car Analogy — Why BMI Exists

The official BMI documentation opens with a brilliant analogy that perfectly captures the motivation:

> *"When you climb in the driver's seat of an unfamiliar car, you are nonetheless presented with a familiar sight. Whatever the make or model may be, we take it for granted that the vehicle will provide a steering wheel, brake pedal, and speedometer. Although we don't usually think of it this way, drivers across the globe benefit from a **standard interface**: a set of control mechanisms and information displays that have essentially the same design regardless of whether the vehicle is a tiny electric two-seater or a giant stretch limousine."*
>
> — BMI Official Documentation (bmi.csdms.io)

This is the core insight. Without BMI, every Earth science model has its own unique way to:
- Start up (some use config files, some use command-line arguments, some hard-code values)
- Run (some have a main loop, some use subroutine calls, some are interactive)
- Share data (some write to files, some use shared memory, some use custom APIs)
- Describe themselves (some have documentation, some... don't)

The CSDMS documentation also uses a **railroad analogy**: trains can be assembled from combinations of all sorts of different rail cars, built by different companies, in different places, and with different purposes — because they all share a standard coupling mechanism. BMI is that coupler for scientific models.

```
WITHOUT BMI — Every model is a unique snowflake:

  WRF-Hydro:     "Read namelist.hrldas, then call wrf_hydro_driver()"
  SCHISM:         "Read param.nml, then call schism_step()"  
  MODFLOW:        "Parse .nam file, then call mf6_run()"
  HydroTrend:     "Load HYDRO.IN, call hydrotrend_main()"
  
  Want to couple any two? Write months of custom glue code.
  Want to couple three? Start over from scratch.

WITH BMI — Every model speaks the same language:

  WRF-Hydro:     initialize("config.yaml") -> update() -> get_value("streamflow")
  SCHISM:         initialize("config.yaml") -> update() -> get_value("water_level")
  MODFLOW:        initialize("config.yaml") -> update() -> get_value("head")
  HydroTrend:     initialize("config.yaml") -> update() -> get_value("discharge")
  
  Want to couple any combination? Just wire get_value -> set_value!
```

---

## 2. What Exactly IS BMI?

### The Official Definition

From bmi.csdms.io:

> *"The Basic Model Interface (BMI) is a **standardized set of control and query functions** that, when added to a software element such as a model or a dataset, makes that software easier to couple with other software that also exposes a BMI."*

Let's break down every word:

- **Standardized** — Same functions, same names, same argument patterns, regardless of model
- **Control functions** — Functions that let you start, stop, advance, and manage a model
- **Query functions** — Functions that let you ask the model about itself (what variables? what grid? what time?)
- **Software element** — Not just models! BMI can also wrap datasets ("Data Components")
- **Easier to couple** — The whole point: connecting multiple models together

### Key Design Properties

From the official documentation and GitHub README, BMI has four critical design properties:

**1. Self-Describing**

A model with a BMI can tell you everything about itself programmatically. You can ask:
- "What is your name?" 
- "What variables do you accept as input?"
- "What variables do you produce as output?"
- "What kind of grid are you on?"
- "What are your time units?"

You never need to read documentation to understand what a BMI model does — you can discover it by calling the BMI functions themselves.

```
ML Analogy: Like model introspection in PyTorch/TensorFlow.
You can call model.parameters(), model.named_modules(), model.input_shape
to understand a model without reading its source code.
```

**2. Non-Invasive**

Adding a BMI does NOT change the model's original code. The BMI is a **wrapper layer** that sits around the existing model. The original model remains untouched and can still run standalone.

```
Your Model (unchanged):       BMI Wrapper (new code you write):
┌─────────────────────┐       ┌──────────────────────────────┐
│                     │       │ initialize():                │
│  Original Fortran   │  <──  │   calls model_init()         │
│  code that works    │       │ update():                    │
│  exactly as before  │  <──  │   calls model_run_one_step() │
│                     │       │ get_value("streamflow"):     │
│                     │  <──  │   returns model%Q_channel    │
└─────────────────────┘       └──────────────────────────────┘
                              
The wrapper translates BMI function calls into your model's 
internal function calls. Your model doesn't even know BMI exists.
```

```
ML Analogy: Like writing an ONNX exporter for your PyTorch model.
The exporter doesn't change your model — it wraps the existing 
forward() function into the ONNX standard format.
```

**3. Zero Dependencies**

A model's BMI does NOT import or depend on any external framework, library, or data structure. It uses only standard language features (basic arrays, strings, numbers). This means:
- The model can still compile and run without any CSDMS software installed
- The BMI doesn't "infect" the model with external requirements
- You can add a BMI and distribute the model to people who have never heard of CSDMS

```
ML Analogy: Like writing a REST API endpoint for your model.
The model doesn't depend on Flask/FastAPI — you just write 
a thin layer that translates HTTP requests into model calls.
```

**4. Language-Agnostic**

The same set of 41 functions is defined for C, C++, Fortran, Java, Python, and (community-contributed) JavaScript and Julia. A BMI model written in Fortran speaks the same "protocol" as one written in Python.

```
BMI Specification (in SIDL - Scientific Interface Definition Language):
  ↓
  ├── C specification (bmi.h)
  ├── C++ specification (bmi.hxx)
  ├── Fortran specification (bmi.f90)      <-- WRF-Hydro would use this
  ├── Java specification (Bmi.java)
  ├── Python specification (bmi.py)
  ├── JavaScript specification (community)
  └── Julia specification (community)
```

### BMI Version

The current version is **BMI 2.0**, published in:

> Hutton, E.W.H., Piper, M.D., and Tucker, G.E., 2020. *The Basic Model Interface 2.0: A standard interface for coupling numerical models in the geosciences.* Journal of Open Source Software, 5(51), 2317.

---

## 3. The Current Status: SCHISM vs WRF-Hydro

This is critical context for your project:

### SCHISM: BMI-Compliant (YES)

SCHISM **already has a BMI implementation**. The repository `schism-dev/schism_NWM_BMI` on GitHub contains the BMI-wrapped version of SCHISM, developed specifically for coupling with the National Water Model through NOAA's NextGen framework.

Key facts about SCHISM's BMI:
- The Fortran BMI wrapper file is called `bmischism.f90`
- It was developed by Jason Ducker (NOAA/NWS/Office of Water Prediction) in collaboration with Dr. Joseph Zhang (VIMS, the SCHISM creator)
- It initially runs in **serial mode** (single thread) to simplify the implementation — no ghost nodes, all variables on global nodes
- It exposes variables like water level boundaries, source term discharges, and atmospheric forcing
- It uses a CPP compile flag `USE_NWM_BMI` to activate BMI-specific code paths
- However, there is currently **NO PyMT plugin** (no `pymt_schism` package exists yet)

### WRF-Hydro: NOT BMI-Compliant (NO)

WRF-Hydro does **not** have a BMI wrapper. It currently:
- Runs as a standalone Fortran program with its own main loop
- Uses Fortran namelists for configuration (`namelist.hrldas`, `hydro.namelist`)
- Reads/writes NetCDF files for data exchange
- Has no standardized API for external control
- There is **no PyMT plugin** either

```
Current State:
┌─────────────────────────────────────────────────────┐
│                                                     │
│   SCHISM ✅ BMI-Compliant    ❌ No PyMT Plugin      │
│   WRF-Hydro ❌ NOT BMI       ❌ No PyMT Plugin      │
│                                                     │
│   YOUR PROJECT GOAL:                                │
│   1. Make WRF-Hydro BMI-compliant (write the BMI)   │
│   2. Create PyMT plugins for both models            │
│   3. Couple them through PyMT                       │
│                                                     │
└─────────────────────────────────────────────────────┘
```

---

## 4. The 41 BMI Functions — Complete Deep Dive

BMI 2.0 specifies exactly **41 functions** organized into 6 categories. Every single one MUST be implemented (even if some just return an error code for "not applicable"). Let's go through every one in detail.

### Category 1: Model Control Functions (The Lifecycle)

These 4 functions control the model's execution lifecycle — starting it up, stepping it forward, and shutting it down.

#### 1. `initialize(config_file)`

**What it does:** Performs all startup tasks for the model. This is the very first BMI function called.

**Details from official docs:**
- Accepts a string `config_file` — the path to a configuration file
- The config file format is NOT mandated by BMI (can be YAML, JSON, Fortran namelist, anything) — but CSDMS recommends YAML
- This function should: read the config, allocate memory, set initial conditions, open input files
- A model should NOT perform any time-stepping in `initialize` — only setup

**For WRF-Hydro, this would need to:**
- Read the `namelist.hrldas` and `hydro.namelist` configuration files
- Load the geographic domain files (terrain, soil properties, channel network)
- Initialize the Noah-MP land surface model state
- Initialize the routing grids (250m overland, channel network)
- Set up internal data structures for time stepping
- All without advancing the model forward in time

```
ML Analogy:

# This is like __init__() + load_weights() in PyTorch:
model = WRFHydroModel()           # __init__
model.load_state_dict(checkpoint)  # loading saved state
model.eval()                       # prepare for inference
# But NOT model.forward() yet!
```

#### 2. `update()`

**What it does:** Advances the model state by exactly **one time step**.

**Details from official docs:**
- No arguments, no return value (in Python; returns status code in C/Fortran)
- This is where the actual computation happens
- After calling `update()`, the model's internal clock has advanced by `get_time_step()` amount
- You can call `update()` repeatedly to advance through the simulation

**For WRF-Hydro, one `update()` call would:**
- Read the next hour of atmospheric forcing (rain, temperature, etc.)
- Run Noah-MP land surface model for one hour on the 1km grid
- Disaggregate to 250m grid, run terrain routing (many internal sub-steps)
- Run channel routing through the river network
- Run groundwater/baseflow
- Advance the internal clock by one hour

```
ML Analogy:

# This is like one forward pass:
output = model.forward(input_batch)  # process one batch
# Or one training iteration:
loss = train_one_step(model, batch)  # one step of training
```

#### 3. `update_until(time)`

**What it does:** Advances the model state until the model's current time equals the given `time`.

**Details from official docs:**
- Takes a float `time` as argument (in the model's time units)
- Essentially calls `update()` repeatedly until `get_current_time() >= time`
- Useful for synchronizing two models with different time steps

**Example scenario:**
```
SCHISM needs data from WRF-Hydro at time = 7200 seconds
WRF-Hydro's time step = 3600 seconds (1 hour)

# Instead of figuring out how many steps:
wrfhydro.update_until(7200.0)
# This internally calls update() twice (3600 -> 7200)
```

```
ML Analogy:

# Like training until a specific epoch:
while model.current_epoch < target_epoch:
    model.train_one_epoch()
```

#### 4. `finalize()`

**What it does:** Performs all cleanup tasks after the simulation is complete.

**Details from official docs:**
- No arguments
- Should: deallocate memory, close files, write final outputs, print summary reports
- After `finalize()`, no other BMI functions should be called (except possibly `initialize()` to restart)

```
ML Analogy:

# Like cleanup after training:
writer.close()           # close TensorBoard writer
torch.cuda.empty_cache() # free GPU memory
del model                # remove model from memory
```

---

### Category 2: Model Information Functions (Self-Description)

These functions let you ask the model about itself — what it is and what variables it works with.

#### 5. `get_component_name()`

**What it does:** Returns the name of the model as a string.

**Examples:**
- WRF-Hydro would return: `"WRF-Hydro National Water Model"`
- SCHISM would return: `"SCHISM Semi-implicit Cross-scale Hydroscience Integrated System Model"`

#### 6. `get_input_item_count()`

**What it does:** Returns the number of input variables the model can accept from outside.

For WRF-Hydro, this might return `5` if we expose: precipitation, temperature, specific humidity, wind speed, and downward shortwave radiation.

#### 7. `get_output_item_count()`

**What it does:** Returns the number of output variables the model produces.

For WRF-Hydro, this might return `4` if we expose: streamflow, soil moisture, snow water equivalent, and evapotranspiration.

#### 8. `get_input_var_names()`

**What it does:** Returns a list of names for all input variables.

**Important note from docs:** These names are *preferably* in the form of **CSDMS Standard Names** (see Section 6). Standard Names enable a framework to automatically match input and output variables between models.

For WRF-Hydro, this might return:
```
[
    "atmosphere_water__precipitation_leq-volume_flux",
    "land_surface_air__temperature",
    "atmosphere_air_water~vapor__relative_saturation",
    "land_surface_wind__speed",
    "land_surface~incoming~shortwave__radiation_flux"
]
```

#### 9. `get_output_var_names()`

**What it does:** Returns a list of names for all output variables.

For WRF-Hydro, this might return:
```
[
    "channel_water_x-section__volume_flow_rate",   (streamflow)
    "soil_water__volume_fraction",                  (soil moisture)
    "snowpack__liquid-equivalent_depth",            (snow water equivalent)
    "land_surface_water__evaporation_volume_flux"   (evapotranspiration)
]
```

---

### Category 3: Variable Information Functions (Metadata)

For each variable (input or output), these functions tell you about its data type, units, size, and which grid it lives on.

#### 10. `get_var_type(name)`

**What it does:** Returns the data type of the named variable as a string.

**From docs:** Use native language type names. In Fortran: `"double precision"`, `"real"`, `"integer"`. In Python: `"float64"`, `"int32"`.

Example: `get_var_type("channel_water_x-section__volume_flow_rate")` returns `"double precision"`

#### 11. `get_var_units(name)`

**What it does:** Returns the physical units of the variable as a string.

**From docs:** Uses UDUNITS conventions. Examples:
- `"m s-1"` for velocity (meters per second)
- `"m3 s-1"` for streamflow (cubic meters per second)
- `"kg m-2 s-1"` for precipitation flux
- `"K"` for temperature in Kelvin
- `"1"` or `""` for dimensionless quantities
- `"none"` for variables without units

This is something ML doesn't typically worry about — but in physical science, unit mismatches cause real bugs! BMI makes units explicit so frameworks can auto-convert.

#### 12. `get_var_itemsize(name)`

**What it does:** Returns the size in bytes of a single element of the variable.

Example: A `"double precision"` value = 8 bytes. So this returns `8`.

```
ML Analogy: Like tensor.element_size() in PyTorch.
torch.float64 -> 8 bytes
torch.float32 -> 4 bytes
```

#### 13. `get_var_nbytes(name)`

**What it does:** Returns the TOTAL size in bytes of the entire variable array.

If streamflow is defined on 2.7 million river reaches, each 8 bytes:
`get_var_nbytes("streamflow")` = 2,700,000 * 8 = 21,600,000 bytes (about 21 MB)

```
ML Analogy: Like tensor.nelement() * tensor.element_size()
```

#### 14. `get_var_grid(name)`

**What it does:** Returns an integer **grid identifier** for the grid this variable lives on.

This is critical because a model can have MULTIPLE grids! WRF-Hydro has at least 3:
- Grid 0: 1km regular grid (for Noah-MP variables like soil moisture)
- Grid 1: 250m regular grid (for routing variables like overland flow)
- Grid 2: Unstructured network (for channel variables like streamflow)

Example: `get_var_grid("soil_moisture")` might return `0` (the 1km grid).

#### 15. `get_var_location(name)`

**What it does:** Returns where on the grid the variable is defined. Valid values:
- `"node"` — defined at grid nodes/vertices
- `"edge"` — defined at grid edges
- `"face"` — defined at grid faces/cells

Most variables are defined at nodes. But some (like flow between cells) might be defined on edges.

---

### Category 4: Time Functions (Temporal Awareness)

These 5 functions describe the model's time characteristics.

#### 16. `get_current_time()`

**What it does:** Returns the current model time as a floating-point number.

After `initialize()`, this returns the start time. After each `update()`, it advances by one time step.

#### 17. `get_start_time()`

**What it does:** Returns the model's start time.

**From docs:** The start time is typically defined to be `0.0`.

#### 18. `get_end_time()`

**What it does:** Returns the model's end time.

**From docs:** If the model doesn't define an end time, return a very large number (e.g., maximum float value).

#### 19. `get_time_step()`

**What it does:** Returns the size of one time step.

For WRF-Hydro: would return `3600.0` (seconds) — one hour.

#### 20. `get_time_units()`

**What it does:** Returns the time units as a string.

**From docs:** Recommends UDUNITS conventions like `"s"`, `"min"`, `"h"`, `"d"`. The docs specifically note: *"Avoid using 'years' as a unit, if possible, since a year is difficult to define precisely."*

A common format is: `"s"` (seconds) or `"seconds since 2020-01-01 00:00:00"`.

---

### Category 5: Getter and Setter Functions (THE COUPLING KEY!)

These are the most important functions for coupling. They let you **extract data from** and **inject data into** a running model.

#### 21. `get_value(name, dest)`

**What it does:** Copies the current values of a variable into a provided array.

**Critical details from docs:**
- The `dest` array must be pre-allocated by the caller (correct size and type)
- The data is COPIED — modifying `dest` does not affect the model
- Arrays are **always flattened to 1D**, even if the model uses 2D/3D data internally
- Variable may not be accessible before `initialize()` or after `finalize()`

**Why flattened?** From the docs: *"This avoids any issues stemming from row/column-major indexing when coupling models written in different languages."* (Fortran uses column-major, C uses row-major — flattening eliminates this ambiguity.)

```python
# Python example of get_value:
import numpy as np

# First, find out how big the array needs to be
nbytes = model.get_var_nbytes("streamflow")
itemsize = model.get_var_itemsize("streamflow")
n_values = nbytes // itemsize  # = 2,700,000

# Allocate the destination array
streamflow = np.zeros(n_values, dtype="float64")

# Copy model data into our array
model.get_value("streamflow", streamflow)

# Now streamflow contains all 2.7 million values!
print(f"Max streamflow: {streamflow.max():.1f} m3/s")
```

#### 22. `get_value_ptr(name)`

**What it does:** Returns a **reference** (pointer) to the model's internal data — NOT a copy.

**From docs:** This is optional and not available in all languages. When available, it's faster because no data copying occurs. But it's dangerous — modifying the returned data directly modifies the model state!

#### 23. `get_value_at_indices(name, dest, inds)`

**What it does:** Gets values only at specific array positions (indices).

Useful when you only need data at certain locations, not the entire grid. For example, getting streamflow at 50 gauge stations out of 2.7 million reaches.

```python
# Get streamflow only at specific river reach indices
gauge_indices = np.array([1234, 5678, 91011, ...])  # 50 stations
gauge_values = np.zeros(50, dtype="float64")
model.get_value_at_indices("streamflow", gauge_values, gauge_indices)
```

#### 24. `set_value(name, src)`

**What it does:** Sets the values of a variable from a provided array.

This is how you **inject data into a model from outside** — the key to coupling!

**Critical details from docs:**
- The `src` array must be the correct size and type
- The data is COPIED into the model's internal storage
- This overwrites the model's current values for that variable

```python
# Inject new precipitation data into WRF-Hydro from another model
new_precipitation = np.array([...])  # 1 million values on 1km grid
model.set_value("atmosphere_water__precipitation_leq-volume_flux", new_precipitation)

# Now when update() runs, it will use this precipitation!
model.update()
```

#### 25. `set_value_at_indices(name, inds, src)`

**What it does:** Sets values only at specific array positions.

Useful for setting boundary conditions or point source inputs.

```python
# Set river discharge at 3 specific inflow points
inflow_indices = np.array([100, 200, 300])
inflow_values = np.array([50.0, 120.0, 30.0])  # m3/s
schism.set_value_at_indices("river_discharge", inflow_indices, inflow_values)
```

---

### Category 6: Grid Functions (Spatial Awareness)

These functions describe the spatial grids. There are 16 grid functions, which is the largest category because Earth science grids can be complex.

#### 26. `get_grid_rank(grid_id)`

**What it does:** Returns the number of dimensions of the grid.

Examples:
- A scalar (single point): rank = 0
- A 1D line of points: rank = 1
- A 2D surface grid: rank = 2
- A 3D volume grid: rank = 3

#### 27. `get_grid_size(grid_id)`

**What it does:** Returns the total number of nodes in the grid.

For WRF-Hydro's 1km grid over CONUS: might return ~1,000,000.

#### 28. `get_grid_type(grid_id)`

**What it does:** Returns the grid type as a string. Valid values:

| Grid Type | Description | Used By |
|---|---|---|
| `"scalar"` | A single point (0D) | Constants, single-station models |
| `"points"` | A set of unconnected points | Station data |
| `"vector"` | A 1D line of connected points | River reach chains |
| `"uniform_rectilinear"` | Regular grid, equal spacing | WRF-Hydro (1km, 250m grids) |
| `"rectilinear"` | Regular grid, variable spacing | Some atmospheric models |
| `"structured_quadrilateral"` | Curvilinear grid | Ocean models, lat-lon grids |
| `"unstructured"` | Triangles/polygons of any shape | SCHISM, finite element models |

This is THE most important grid function because it determines which other grid functions are needed.

#### 29-31. `get_grid_shape()`, `get_grid_spacing()`, `get_grid_origin()`

**What they do:** For **uniform rectilinear** grids only:
- `shape` returns dimensions like `[1000, 1000]` (rows, columns)
- `spacing` returns cell sizes like `[1000.0, 1000.0]` (meters)
- `origin` returns the corner coordinate like `[lat_min, lon_min]`

**From docs:** Shape uses "ij" indexing (rows first, then columns), NOT "xy" indexing. This is a common source of bugs.

#### 32-34. `get_grid_x()`, `get_grid_y()`, `get_grid_z()`

**What they do:** Return arrays of coordinates for grid nodes.

For structured grids: return coordinate arrays for each axis.
For unstructured grids: return the x,y,z coordinate of EVERY node.

#### 35-41. Unstructured Grid Functions

For unstructured grids (like SCHISM's triangular mesh), additional functions describe the connectivity:

| Function | What It Returns |
|---|---|
| `get_grid_node_count()` | Total number of nodes (vertices) |
| `get_grid_edge_count()` | Total number of edges |
| `get_grid_face_count()` | Total number of faces (cells) |
| `get_grid_edge_nodes()` | For each edge: which two nodes connect? |
| `get_grid_face_edges()` | For each face: which edges bound it? |
| `get_grid_face_nodes()` | For each face: which nodes are its vertices? |
| `get_grid_nodes_per_face()` | How many nodes per face? (3 for triangles, 4 for quads) |

```
ML Analogy:

These are exactly like defining a graph structure for GNNs:
- Nodes = grid points
- Edges = connections between nodes
- Faces = cells (polygons)
- edge_nodes = edge_index in PyTorch Geometric
- face_nodes = the adjacency information

SCHISM's unstructured grid IS a graph, described by these functions.
```

---

## 5. Grid Types in BMI — Complete Guide

The grid type system is one of BMI's most important features. Here's the complete hierarchy:

```
BMI Grid Types
│
├── STRUCTURED (regular patterns)
│   ├── scalar ............. Single point (0D)
│   │                        One value, no spatial extent
│   │                        Example: A model with one output number
│   │
│   ├── points ............ Set of disconnected points (0D+)
│   │                        Multiple points with x,y coordinates but no connections
│   │                        Example: Weather station locations
│   │
│   ├── vector ............ 1D line of connected points
│   │                        Points connected in sequence
│   │                        Example: River centerline, cross-section
│   │
│   ├── uniform_rectilinear  Regular grid, equal cell sizes
│   │                        Fully described by: shape, spacing, origin
│   │                        Example: WRF-Hydro 1km grid, satellite images
│   │                        ML Analogy: Like a regular image tensor
│   │
│   ├── rectilinear ........ Regular grid, variable spacing along axes
│   │                        Rows and columns still straight, but not equally spaced
│   │                        Example: A grid that is finer near the surface
│   │
│   └── structured_quadrilateral  Curvilinear (bent) grid
│                            Rows/columns don't share common coordinates
│                            Example: Global lat-lon grid on a sphere
│
└── UNSTRUCTURED (irregular patterns)
    └── unstructured ......  Arbitrary polygons (triangles, quads, etc.)
                             Must describe all node positions AND connectivity
                             Example: SCHISM's triangular mesh
                             ML Analogy: Like a graph in PyTorch Geometric
```

### Which Functions Each Grid Type Needs

Not all grid functions are needed for every grid type (but all MUST be implemented — unused ones can return error codes):

| Function | scalar | points | vector | uniform_rect | rectilinear | struct_quad | unstructured |
|---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| `get_grid_rank` | x | x | x | x | x | x | x |
| `get_grid_size` | x | x | x | x | x | x | x |
| `get_grid_type` | x | x | x | x | x | x | x |
| `get_grid_shape` | | | | x | x | x | |
| `get_grid_spacing` | | | | x | | | |
| `get_grid_origin` | | | | x | | | |
| `get_grid_x` | | x | x | | x | x | x |
| `get_grid_y` | | x | x | | x | x | x |
| `get_grid_z` | | | | | | | x |
| `get_grid_node_count` | | | | | | | x |
| `get_grid_edge_count` | | | | | | | x |
| `get_grid_face_count` | | | | | | | x |
| `get_grid_edge_nodes` | | | | | | | x |
| `get_grid_face_edges` | | | | | | | x |
| `get_grid_face_nodes` | | | | | | | x |
| `get_grid_nodes_per_face` | | | | | | | x |

---

## 6. CSDMS Standard Names

Variable names are a surprisingly difficult problem in model coupling. If WRF-Hydro calls its output "STREAMFLOW" and SCHISM expects input called "river_inflow_rate", how does a framework know they mean the same thing?

**CSDMS Standard Names** solve this with a rigorous naming convention.

### The Structure

Every Standard Name has two parts:

```
OBJECT__QUANTITY

  object = what thing you're talking about
  quantity = what measurement of that thing

  Separated by double underscore: __
```

### Examples Relevant to Your Project

| What Scientists Call It | CSDMS Standard Name | Explanation |
|---|---|---|
| Streamflow | `channel_water_x-section__volume_flow_rate` | Water in a channel cross-section, measured as volume flow rate |
| Precipitation | `atmosphere_water__precipitation_leq-volume_flux` | Water in the atmosphere, as precipitation liquid-equivalent volume flux |
| Soil moisture | `soil_water__volume_fraction` | Water in the soil, as a fraction of total volume |
| Temperature | `land_surface_air__temperature` | Air at the land surface, measured as temperature |
| Water level | `sea_water_surface__elevation` | Sea water surface, measured as elevation |
| Snow depth | `snowpack__liquid-equivalent_depth` | Snowpack, measured as liquid-equivalent depth |
| Evaporation | `land_surface_water__evaporation_volume_flux` | Water at the land surface, as evaporation volume flux |

### Key Rules from Documentation

1. **You do NOT need to use Standard Names internally.** Your model can use any variable names it wants. The BMI wrapper maps between Standard Names (exposed externally) and internal names.

2. **Don't rename your internal variables.** Instead, write a mapping: `"channel_water_x-section__volume_flow_rate" -> model%STREAMFLOW`

3. Standard Names enable **automatic coupling** — a framework can look at Model A's output names and Model B's input names and match them without human intervention.

---

## 7. BMI Best Practices — Official Wisdom

The official BMI documentation (bmi.csdms.io/en/stable/bmi.best_practices.html) provides critical implementation advice. Here are the key points:

### 1. All 41 Functions Must Be Implemented

Even if your model doesn't use a particular feature. A model on a regular grid still needs `get_grid_face_nodes()` — but it can simply return `BMI_FAILURE` (in C/Fortran) or raise `NotImplementedError` (in Python).

### 2. The IRF Refactoring Pattern

This is **the most difficult part** of adding a BMI, according to the official docs:

> *"Before fitting a model with a BMI, the model code may have to be **refactored into modular initialize-run-finalize (IRF) steps** in order to interact with the BMI functions. This is often the most difficult part of adding a BMI, but the modularization tends to improve the quality of the code."*

Most scientific models are written as one big program: read config, run a loop, write output, done. BMI requires you to break this into three separate callable functions: Initialize, Run-one-step, and Finalize.

```
BEFORE refactoring (typical Fortran model):

  program main
    call read_config()
    call setup_grid()
    do t = 1, nsteps          <-- The main loop
      call read_forcing(t)
      call compute(t)
      call write_output(t)
    end do
    call cleanup()
  end program

AFTER refactoring (BMI-ready):

  subroutine model_init(config_file)    <-- Called by BMI initialize()
    call read_config(config_file)
    call setup_grid()
  end subroutine

  subroutine model_step()               <-- Called by BMI update()
    call read_forcing(current_time)
    call compute(current_time)
    current_time = current_time + dt
  end subroutine

  subroutine model_finalize()            <-- Called by BMI finalize()
    call cleanup()
  end subroutine
```

**For WRF-Hydro, this means:**
WRF-Hydro's main program has an integrated time loop. The BMI implementation must "break open" this loop so that an external caller can advance the model one step at a time. This requires separating the initialization phase from the time-stepping phase and ensuring the model state is fully persistent between calls.

### 3. Flatten All Arrays

> *"BMI functions always use flattened, one-dimensional arrays. This avoids any issues stemming from row/column-major indexing when coupling models written in different languages."*

Even if WRF-Hydro stores soil moisture as a 2D array `soil_moisture(1000, 1000)`, the BMI `get_value` function must return it as a flattened 1D array of 1,000,000 elements. The developer must ensure proper ordering (row-major vs column-major).

### 4. Multiple Grids Are Encouraged

> *"Models can have multiple grids. This can be particularly useful for defining exchange items that don't vary over the model domain; e.g., a diffusivity — just define the variable on a separate scalar grid."*

WRF-Hydro naturally has multiple grids (1km, 250m, river network), so this maps well. Each gets a unique integer ID (0, 1, 2...).

### 5. Use Configuration Files (YAML Recommended)

> *"Models should be refactored, if necessary, to use a configuration file. CSDMS does not impose any constraint on how configuration files are formatted, although YAML is recommended."*

WRF-Hydro already uses Fortran namelists, which is fine. The BMI config file could either point to the existing namelists or be a YAML file that wraps them.

### 6. Memory Allocation Is the Model's Job

> *"Avoid allocating memory within a BMI function. Memory allocation is typically the responsibility of the model."*

The BMI wrapper should NOT create new data structures. It should just provide access to data the model has already allocated internally.

### 7. Avoid Global State

> *"If a model only uses local variables, its BMI will be self-contained. This may allow multiple instances of the model to be run simultaneously, possibly permitting the model to be coupled with itself."*

This is a challenge for WRF-Hydro, which uses many Fortran module-level (global) variables. Encapsulating state into a derived type would be the ideal fix but may be too invasive for an initial BMI.

---

## 8. Applying BMI to WRF-Hydro — What Needs to Happen

Given that WRF-Hydro is NOT BMI-compliant, here's what needs to happen:

### The Core Challenge

WRF-Hydro is a large, self-contained Fortran program. Its main program (`wrf_hydro_driver`) contains:
1. A call to initialization routines
2. A time loop that runs the full simulation
3. A call to finalization routines

To make it BMI-compliant, you must **decompose this self-contained loop** so that:
- An external caller can trigger initialization once
- An external caller can advance one step at a time
- Between steps, the model state is fully preserved
- An external caller can read/write any exposed variable
- An external caller can trigger finalization once

### What the BMI Wrapper File Would Look Like

You would create a new Fortran file (e.g., `bmi_wrf_hydro.f90`) that:

```
bmi_wrf_hydro.f90 (new file, does NOT modify existing WRF-Hydro code):

  module bmi_wrf_hydro
    use bmif_2_0         ! Import the BMI Fortran specification
    use wrf_hydro_state  ! Import WRF-Hydro's internal state
    implicit none
    
    type, extends(bmi) :: bmi_wrf_hydro_model
      ! Internal state references
      contains
        procedure :: initialize
        procedure :: update  
        procedure :: finalize
        procedure :: get_value
        procedure :: set_value
        ... (all 41 functions)
    end type
    
  contains
    
    function initialize(self, config_file) result(status)
      ! Call WRF-Hydro's existing initialization routines
      ! But DON'T enter the time loop
    end function
    
    function update(self) result(status)
      ! Execute exactly ONE step of WRF-Hydro's time loop
    end function
    
    function get_value(self, name, dest) result(status)
      ! Map Standard Name to internal variable
      ! Copy internal data into dest array (flattened 1D)
    end function
    
    ... etc for all 41 functions
    
  end module
```

### Decisions You Must Make

| Decision | Options | Recommendation |
|---|---|---|
| Which variables to expose? | All ~100+ internal variables vs. key 5-10 | Start with 5-10 key ones |
| Which grids to expose? | 1km only, 250m only, channel, or all | Start with 1km + channel |
| Standalone or coupled mode? | File-based forcing vs. injected forcing | File-based first, then add injection |
| Serial or parallel? | Strip MPI vs. keep internal MPI | Serial first for simplicity |
| Config file format? | YAML wrapper vs. pass-through to namelists | Pass-through to existing namelists |

---

## 9. SCHISM's BMI — A Reference Example

Since SCHISM already has a BMI (`schism-dev/schism_NWM_BMI`), it serves as a valuable reference for how a large Fortran model can be BMI-wrapped.

### Key Implementation Details

1. **The BMI file:** `bmischism.f90` — contains all 41 BMI function implementations
2. **Compile flag:** `USE_NWM_BMI` — a CPP preprocessor flag that activates BMI-specific code paths in SCHISM
3. **Serial mode:** The initial BMI runs SCHISM on a single thread, eliminating MPI complexity
4. **Variable naming:** Variables use simple names like `"discharge"` and `"water_level"` mapped to internal SCHISM arrays
5. **Time handling:** SCHISM's semi-implicit time stepping means it needs forcing data one step ahead — the BMI handles this by treating the first step specially (setting t0 = t1 until real data arrives)
6. **Configuration:** A BMI configuration file points to the existing SCHISM `param.nml` and other input files
7. **Test driver:** A separate program `schism_BMI_driver_test.f90` tests the BMI by calling initialize → update loops → finalize
8. **NextGen integration:** SCHISM's BMI was designed for NOAA's NextGen Water Resources Modeling Framework, which also uses BMI as its model interface standard

### What You Can Learn From SCHISM's Approach

- Start with **serial mode** (no MPI) — this dramatically simplifies the initial implementation
- Use **CPP flags** to keep BMI-specific code separate from the main model code
- Begin with a **minimal set of exchange variables** and expand later
- Create a **test driver** program to verify the BMI works before integrating into any framework
- The **hardest part** is handling the model's time-stepping scheme — SCHISM's look-ahead requirement needed special handling

---

## 10. The Heat Model Example — BMI in Action

CSDMS provides a simple example model called "Heat" that solves the heat diffusion equation. This example exists in all supported languages and is the recommended starting point.

### How It Works Conceptually

The Heat model simulates temperature spreading across a rectangular plate over time. It's simple enough to understand but demonstrates all BMI concepts.

```python
# Python example of using the Heat model through BMI:
from bmi_heat import BmiHeat
import numpy as np

# Create and initialize
model = BmiHeat()
model.initialize("test_config.yaml")

# Ask the model about itself
print(model.get_component_name())         # "The 2D Heat Equation"
print(model.get_input_var_names())        # ["plate_surface__temperature"]  
print(model.get_output_var_names())       # ["plate_surface__temperature"]

# Ask about the grid
grid_id = model.get_var_grid("plate_surface__temperature")
grid_type = model.get_grid_type(grid_id)  # "uniform_rectilinear"
grid_shape = np.zeros(2, dtype="int32")
model.get_grid_shape(grid_id, grid_shape) # [10, 20] (10 rows, 20 columns)

# Ask about time
print(model.get_time_units())       # "s" (seconds)
print(model.get_time_step())        # 0.25
print(model.get_current_time())     # 0.0

# Run 100 time steps
for _ in range(100):
    model.update()

print(model.get_current_time())     # 25.0  (100 * 0.25)

# Get the temperature field
temp = np.zeros(200)  # 10 * 20 = 200, flattened!
model.get_value("plate_surface__temperature", temp)

# Reshape to see as 2D
temp_2d = temp.reshape(10, 20)
print(f"Center temperature: {temp_2d[5, 10]:.2f}")

# Clean up
model.finalize()
```

This simple example demonstrates EVERY concept: initialize, update, get_value, grid queries, time queries, flattened arrays.

---

## 11. Key References & Links

### Official Documentation
| Resource | URL |
|---|---|
| BMI Home Page | https://bmi.csdms.io |
| BMI Specification (all functions) | https://bmi.csdms.io/en/stable/bmi.spec.html |
| BMI Best Practices | https://bmi.csdms.io/en/stable/bmi.best_practices.html |
| BMI Getting Started Guide | https://bmi.csdms.io/en/stable/bmi.getting_started.html |
| BMI Grid Types | https://bmi.csdms.io/en/stable/model_grids.html |
| BMI GitHub Repository | https://github.com/csdms/bmi |
| CSDMS Wiki - BMI Page | https://csdms.colorado.edu/wiki/BMI |

### Language Specifications
| Language | Spec Repository | Example Implementation |
|---|---|---|
| Python | https://github.com/csdms/bmi-python | https://github.com/csdms/bmi-example-python |
| Fortran | https://github.com/csdms/bmi-fortran | https://github.com/csdms/bmi-example-fortran |
| C | https://github.com/csdms/bmi-c | https://github.com/csdms/bmi-example-c |
| C++ | https://github.com/csdms/bmi-cxx | https://github.com/csdms/bmi-example-cxx |

### SCHISM BMI Implementation
| Resource | URL |
|---|---|
| SCHISM BMI Repository | https://github.com/schism-dev/schism_NWM_BMI |
| SCHISM BMI Discussion | https://github.com/schism-dev/schism-esmf/issues/25 |
| NextGen SCHISM Integration | https://github.com/NOAA-OWP/ngen/issues/547 |

### Standard Names
| Resource | URL |
|---|---|
| Standard Names Documentation | https://standard-names.readthedocs.io |
| Standard Names Repository | https://github.com/csdms/standard_names |

### Related Tools
| Tool | URL |
|---|---|
| Babelizer (Fortran → Python) | https://babelizer.readthedocs.io |
| PyMT (Model Coupling Framework) | https://pymt.readthedocs.io |
| BMI Tester (Validate your BMI) | https://github.com/csdms/bmi-tester |

### Academic Citation
> Hutton, E.W.H., Piper, M.D., and Tucker, G.E., 2020. *The Basic Model Interface 2.0: A standard interface for coupling numerical models in the geosciences.* Journal of Open Source Software, 5(51), 2317, https://doi.org/10.21105/joss.02317

---

*Compiled from official CSDMS BMI documentation (bmi.csdms.io), GitHub repositories (github.com/csdms/bmi), SCHISM BMI development discussions, and BMI best practices guides. All function descriptions sourced from the BMI 2.0 specification.*
