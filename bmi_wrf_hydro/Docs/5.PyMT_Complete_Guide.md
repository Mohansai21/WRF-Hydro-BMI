# ğŸ§° PyMT â€” Python Modeling Toolkit â€” Complete Guide

> **The Conductor of the Model Orchestra**
> *Run, Couple, and Orchestrate Any BMI Model from Python*

---

## ğŸ“š Official Sources Used

| Source | URL |
|--------|-----|
| PyMT GitHub | https://github.com/csdms/pymt |
| PyMT ReadTheDocs | https://pymt.readthedocs.io |
| CSDMS Wiki: PyMT | https://csdms.colorado.edu/wiki/PyMT |
| PyMT Quickstart | https://pymt.readthedocs.io/en/latest/quickstart.html |
| BMI Docs: Babelizer & PyMT | https://bmi.csdms.io/en/latest/csdms.html |
| CSDMS Workbench | https://csdms.colorado.edu/wiki/Workbench |
| PyMT Anaconda Package | https://anaconda.org/conda-forge/pymt |
| PyMT GitHub Page | https://csdms.github.io/pymt/ |
| Hutton et al. (2016) AGU Abstract | https://ui.adsabs.harvard.edu/abs/2016AGUFMEP43A0941H |

---

## 1ï¸âƒ£ What Is PyMT?

### ğŸ¯ The Official Definition

From the official PyMT GitHub repository:

> *"pymt is an Open Source Python package, developed by the Community Surface Dynamics Modeling System (CSDMS), that provides the necessary tools used for the coupling of models that expose the Basic Model Interface (BMI)."*

### ğŸ¼ The Orchestra Conductor Analogy

If individual models are **musicians** (each playing their own instrument in their own tempo), then PyMT is the **conductor** who:

- ğŸµ Tells each musician when to play (time stepping)
- ğŸ¶ Translates sheet music between instruments (variable name mapping)
- ğŸ”„ Passes melodies between sections (data exchange)
- ğŸ—ºï¸ Adjusts arrangements for different seating (grid mapping)
- ğŸ“ Records the performance (NetCDF output)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                        â”‚
â”‚                           PyMT ORCHESTRATOR                            â”‚
â”‚                                                                        â”‚
â”‚    WRF-Hydro              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              SCHISM         â”‚
â”‚    (Fortran)              â”‚              â”‚              (Fortran)       â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   BMI      â”‚  â±ï¸ Time     â”‚    BMI       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚    â”‚ Land    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚    Stepping  â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Ocean   â”‚   â”‚
â”‚    â”‚ Rivers  â”‚  get/set   â”‚              â”‚  get/set    â”‚ Coast   â”‚   â”‚
â”‚    â”‚ Soil    â”‚  values    â”‚  ğŸ—ºï¸ Grid     â”‚  values     â”‚ Tides   â”‚   â”‚
â”‚    â”‚ Snow    â”‚            â”‚    Mapping   â”‚             â”‚ Surge   â”‚   â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚              â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â”‚  ğŸ“› Name     â”‚                            â”‚
â”‚                           â”‚    Matching  â”‚                            â”‚
â”‚                           â”‚              â”‚                            â”‚
â”‚                           â”‚  ğŸ“ Unit     â”‚                            â”‚
â”‚                           â”‚    Conversionâ”‚                            â”‚
â”‚                           â”‚              â”‚                            â”‚
â”‚                           â”‚  ğŸ’¾ NetCDF   â”‚                            â”‚
â”‚                           â”‚    Output    â”‚                            â”‚
â”‚                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                                                                        â”‚
â”‚    All controlled from Python. All models run at native speed.        â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> ğŸ“Œ **ML Analogy:** PyMT is like **Hugging Face Transformers** or **Lightning AI** â€” a framework where you can load pre-built model components (plugins), configure them, run them, and chain their inputs/outputs together, all from Python, even though the underlying models may be written in C++/Fortran.

---

## 2ï¸âƒ£ The Six Pillars of PyMT

### ğŸ›ï¸ PyMT's Core Capabilities

From the official documentation, PyMT contains these six key features:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                        â”‚
â”‚  PILLAR 1: GRID MAPPERS                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
â”‚  Tools for coupling models of DISPARATE SPACE scales.                  â”‚
â”‚  When Model A uses a 1km grid and Model B uses a triangular mesh,      â”‚
â”‚  grid mappers interpolate data between them.                           â”‚
â”‚                                                                        â”‚
â”‚  PILLAR 2: TIME STEPPERS                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  Time-steppers that COORDINATE the sequencing of coupled models.       â”‚
â”‚  When Model A runs hourly and Model B runs every 100 seconds,          â”‚
â”‚  time steppers synchronize them.                                       â”‚
â”‚                                                                        â”‚
â”‚  PILLAR 3: DATA EXCHANGE                                               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                â”‚
â”‚  Exchange of data between BMI-enabled models.                          â”‚
â”‚  The get_value/set_value pipeline with automatic conversions.          â”‚
â”‚                                                                        â”‚
â”‚  PILLAR 4: AUTO-LOADING WRAPPERS                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Wrappers that AUTOMATICALLY load BMI-enabled models                   â”‚
â”‚  into the PyMT framework. Just import and go!                          â”‚
â”‚                                                                        â”‚
â”‚  PILLAR 5: STANDARDS UTILITIES                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Utilities that support open-source interfaces:                        â”‚
â”‚  UGRID, SGRID, CSDMS Standard Names, etc.                             â”‚
â”‚                                                                        â”‚
â”‚  PILLAR 6: PLUGIN FRAMEWORK                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                             â”‚
â”‚  A plug-in framework for ADDING additional BMI-enabled                 â”‚
â”‚  models to the framework.                                              â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3ï¸âƒ£ Pillar 1 Deep Dive: Grid Mappers

### ğŸ—ºï¸ The Grid Problem

This is the **single biggest technical challenge** in coupling WRF-Hydro and SCHISM:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                        â”‚
â”‚   WRF-Hydro Grid                        SCHISM Grid                   â”‚
â”‚   (uniform_rectilinear)                 (unstructured)                â”‚
â”‚                                                                        â”‚
â”‚   â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”                    /\    /\                        â”‚
â”‚   â”œâ”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¤                   /  \  /  \                       â”‚
â”‚   â”œâ”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¤                  /    \/    \                      â”‚
â”‚   â”œâ”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¤                 /\   /\    /\                      â”‚
â”‚   â”œâ”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¼â”€â”€â”¤                /  \ /  \  /  \                     â”‚
â”‚   â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜               /    X    \/    \                    â”‚
â”‚                                 /  /   \   /\     \                   â”‚
â”‚   1km x 1km squares            /\/      \ /  \     \                  â”‚
â”‚   Every cell = same size       Triangles of varying sizes             â”‚
â”‚   Row/column indexing          Fine near coast, coarse in ocean       â”‚
â”‚                                                                        â”‚
â”‚   HOW DO YOU TRANSFER DATA BETWEEN THESE TWO GRIDS?                   â”‚
â”‚   â†’ That's what grid mappers do!                                      â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”§ PyMT's Grid Mapping Methods

PyMT provides multiple interpolation methods in the `pymt.mappers` module:

| Mapper | Method | Best For |
|--------|--------|----------|
| **NearestVal** (PointToPoint) | Nearest-neighbor | Quick, no smoothing needed |
| **CellToPoint** | Area-weighted from cells to points | Conserving quantities from structured â†’ unstructured |
| **PointToCell** | Point values averaged into cells | Unstructured â†’ structured |

**How it works:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                  â”‚
â”‚  1. PyMT reads the grid info from BOTH models                   â”‚
â”‚     (using BMI's get_grid_type, get_grid_x, get_grid_y, etc.)   â”‚
â”‚                                                                  â”‚
â”‚  2. PyMT builds a KD-Tree spatial index of the grid points      â”‚
â”‚     (for fast nearest-neighbor lookups)                          â”‚
â”‚                                                                  â”‚
â”‚  3. For each destination grid point, PyMT finds the              â”‚
â”‚     nearest source grid point(s)                                 â”‚
â”‚                                                                  â”‚
â”‚  4. Values are interpolated / averaged / copied                  â”‚
â”‚                                                                  â”‚
â”‚  5. The mapped values are passed to the destination model        â”‚
â”‚     via set_value()                                              â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸŒ Grid Standards Supported

PyMT understands multiple grid conventions:

| Standard | What It Defines | Used By |
|----------|----------------|---------|
| **UGRID** | Unstructured grid convention | SCHISM, FVCOM, ADCIRC |
| **SGRID** | Staggered structured grid | WRF-Hydro, ROMS |
| **CF Conventions** | Climate & Forecast metadata | NetCDF files |

> ğŸ“Œ **ML Analogy:** Grid mappers are like **torch.nn.functional.interpolate()** â€” resizing a feature map from one spatial resolution to another. Except here, the grids can be fundamentally different shapes (regular vs triangular), not just different sizes.

---

## 4ï¸âƒ£ Pillar 2 Deep Dive: Time Steppers

### â±ï¸ The Time Synchronization Problem

WRF-Hydro and SCHISM run at very different time scales:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚  WRF-Hydro: 1-hour time step (3600 seconds)                         â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                       â”‚
â”‚  t=0       t=3600    t=7200    t=10800   t=14400                     â”‚
â”‚                                                                      â”‚
â”‚  SCHISM: ~100-second time step                                       â”‚
â”‚  â”œâ”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤â”€â”€â”¤           â”‚
â”‚  t=0  100  200  300  ...  3500  3600                                 â”‚
â”‚                                                                      â”‚
â”‚  For every 1 WRF-Hydro step, SCHISM takes ~36 steps!                â”‚
â”‚                                                                      â”‚
â”‚  HOW do you keep them in sync?                                       â”‚
â”‚  â†’ Time steppers manage this!                                        â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ¯ PyMT's Time Synchronization Strategy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚  OPTION A: Lock-step (simple)                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                          â”‚
â”‚  Both models advance to the SAME target time.                        â”‚
â”‚  WRF-Hydro does 1 step (3600s), SCHISM does 36 steps (36Ã—100s).    â”‚
â”‚  Data exchange happens at each synchronization point.                â”‚
â”‚                                                                      â”‚
â”‚  â”Œâ”€ WRF-Hydro â”€â”          â”Œâ”€ WRF-Hydro â”€â”                          â”‚
â”‚  â”‚ 1 big step   â”‚â”€â”€DATAâ”€â”€â†’â”‚ 1 big step   â”‚â”€â”€DATAâ”€â”€â†’...              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â†•     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â†•                      â”‚
â”‚  â”Œâ”€ SCHISM â”€â”€â”€â”€â”€â”          â”Œâ”€ SCHISM â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚ 36 small     â”‚â”€â”€DATAâ”€â”€â†’â”‚ 36 small     â”‚â”€â”€DATAâ”€â”€â†’...              â”‚
â”‚  â”‚ steps        â”‚          â”‚ steps        â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                      â”‚
â”‚  OPTION B: update_until() (recommended)                              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚  Both models use update_until(target_time) to advance                â”‚
â”‚  to a common synchronization time. The model internally              â”‚
â”‚  decides how many sub-steps it needs.                                â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5ï¸âƒ£ Pillar 3 Deep Dive: Data Exchange

### ğŸ“¤ğŸ“¥ The get_value â†’ set_value Pipeline

This is the heart of model coupling. PyMT automates the entire chain:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚    STEP 1: EXTRACT                                                   â”‚
â”‚    data = wrfhydro.get_value("channel_water__volume_flow_rate")      â”‚
â”‚    â†’ Returns: NumPy array, FLATTENED to 1D                          â”‚
â”‚    â†’ Values on WRF-Hydro's 1km grid                                â”‚
â”‚                                                                      â”‚
â”‚    STEP 2: UNIT CONVERSION (automatic)                               â”‚
â”‚    PyMT checks: source units = "m3 s-1"                             â”‚
â”‚                  dest units   = "m3 s-1"                             â”‚
â”‚    If different â†’ converts automatically using UDUNITS               â”‚
â”‚                                                                      â”‚
â”‚    STEP 3: GRID MAPPING (automatic)                                  â”‚
â”‚    PyMT interpolates from WRF-Hydro 1km grid                        â”‚
â”‚    â†’ SCHISM unstructured triangular mesh                            â”‚
â”‚    Uses the grid mapper selected during setup                        â”‚
â”‚                                                                      â”‚
â”‚    STEP 4: NAME MATCHING (automatic)                                 â”‚
â”‚    PyMT matches Standard Names:                                      â”‚
â”‚    "channel_water__volume_flow_rate" in Model A                      â”‚
â”‚    = "channel_water__volume_flow_rate" in Model B                    â”‚
â”‚    â†’ Confirmed match!                                                â”‚
â”‚                                                                      â”‚
â”‚    STEP 5: INJECT                                                    â”‚
â”‚    schism.set_value("channel_water__volume_flow_rate", mapped_data)  â”‚
â”‚    â†’ Values now on SCHISM's unstructured grid                       â”‚
â”‚    â†’ SCHISM uses them in its next time step                         â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”‘ What PyMT Adds BEYOND Raw BMI

When a model is loaded into PyMT, it **automatically gains** these capabilities (from the official BMI docs):

| Capability | Description |
|-----------|-------------|
| ğŸ“ **NetCDF Output** | Write output variables to standardized NetCDF files |
| ğŸ“› **Name Mapping** | Automatic matching via CSDMS Standard Names |
| ğŸ“ **Unit Conversion** | Automatic unit conversion via UDUNITS |
| ğŸ—ºï¸ **Grid Mapping** | Interpolation between different grid types |
| â±ï¸ **Time Sync** | Coordinate different time-stepping schemes |
| ğŸ”Œ **Language Bridge** | Run C/C++/Fortran models from Python seamlessly |
| ğŸ§ª **Interactive Use** | Run models in Jupyter Notebooks interactively |
| ğŸ“Š **Introspection** | Query model properties at runtime |

---

## 6ï¸âƒ£ Pillar 4 & 6: Plugin System & Auto-Loading

### ğŸ”Œ How Models Become PyMT Plugins

PyMT uses a **plugin architecture**. Each babelized model becomes a plugin that PyMT auto-discovers:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚  The PyMT Plugin Ecosystem                                           â”‚
â”‚                                                                      â”‚
â”‚  conda install pymt pymt_hydrotrend pymt_cem pymt_child              â”‚
â”‚                                                                      â”‚
â”‚  >>> import pymt                                                     â”‚
â”‚  >>> pymt.MODELS                                                     â”‚
â”‚  {'Hydrotrend', 'Cem', 'Waves', 'Child', 'FrostNumber',             â”‚
â”‚   'Sedflux3D', 'Plume', 'Subside', 'Avulsion', 'Ku'}               â”‚
â”‚                                                                      â”‚
â”‚  Each model was:                                                     â”‚
â”‚  1. Written in C/C++/Fortran (original language)                     â”‚
â”‚  2. Given a BMI wrapper                                              â”‚
â”‚  3. Babelized into a Python package (pymt_<name>)                   â”‚
â”‚  4. Registered with PyMT's plugin system                             â”‚
â”‚  5. Auto-discovered when you import pymt!                            â”‚
â”‚                                                                      â”‚
â”‚  FUTURE (our project):                                               â”‚
â”‚  >>> pymt.MODELS                                                     â”‚
â”‚  {'Hydrotrend', 'Cem', ..., 'WrfHydro', 'Schism'}  â† NEW!         â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“¦ Existing PyMT Plugins

Some models already available as PyMT plugins (from the pymt-lab GitHub organization):

| Plugin Package | Model | Domain |
|---------------|-------|--------|
| `pymt_hydrotrend` | HydroTrend | Hydrology (water/sediment discharge) |
| `pymt_cem` | CEM | Coastal evolution |
| `pymt_child` | CHILD | Landscape evolution |
| `pymt_sedflux` | Sedflux3D | Sediment transport |
| `pymt_plume` | Plume | Sediment plumes |
| `pymt_subside` | Subside | Subsidence |
| `pymt_avulsion` | Avulsion | River avulsion |
| `pymt_ku` | Ku | Fluvial erosion |
| `pymt_waves` | Waves | Wave generation |
| `pymt_gridmet` | gridMET | Meteorological data (Data Component) |
| `pymt_geotiff` | GeoTiff | GeoTIFF data access (Data Component) |

**Not yet available (OUR PROJECT):**

| Plugin Package | Model | Status |
|---------------|-------|--------|
| `pymt_wrfhydro` | WRF-Hydro | âŒ Must write BMI first, then babelize |
| `pymt_schism` | SCHISM | âš ï¸ BMI exists, must babelize |

---

## 7ï¸âƒ£ The Coupling Workflow in PyMT

### ğŸ”— Official Example: CEM + Waves

From the official PyMT README (https://github.com/csdms/pymt), here's a real coupling example that shows the pattern:

```python
from pymt.models import Cem, Waves

# Create model instances
waves = Waves()
cem = Cem()

# Initialize both models
waves.initialize(*waves.setup())
cem.initialize(*cem.setup())

# Coupling loop
for time in range(1000):
    # 1. Advance the waves model
    waves.update()
    
    # 2. Get wave angle from Waves model
    angle = waves.get_value("wave_angle")
    
    # 3. Pass it to CEM model
    cem.set_value("wave_angle", angle)
    
    # 4. Advance the CEM model
    cem.update()
```

**This is the EXACT pattern we will use for WRF-Hydro + SCHISM!**

### ğŸŒŠ Our Future Coupling Script (Conceptual)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚  from pymt.models import WrfHydro, Schism     â† After babelizing   â”‚
â”‚                                                                      â”‚
â”‚  # Create instances                                                  â”‚
â”‚  wrfhydro = WrfHydro()                                               â”‚
â”‚  schism = Schism()                                                   â”‚
â”‚                                                                      â”‚
â”‚  # Initialize                                                        â”‚
â”‚  wrfhydro.initialize(*wrfhydro.setup())                              â”‚
â”‚  schism.initialize(*schism.setup())                                  â”‚
â”‚                                                                      â”‚
â”‚  # Coupling loop (e.g., 24 hours, sync every hour)                   â”‚
â”‚  for hour in range(24):                                              â”‚
â”‚      target_time = (hour + 1) * 3600                                 â”‚
â”‚                                                                      â”‚
â”‚      # Advance WRF-Hydro by 1 hour                                   â”‚
â”‚      wrfhydro.update_until(target_time)                              â”‚
â”‚                                                                      â”‚
â”‚      # Get discharge from WRF-Hydro                                  â”‚
â”‚      discharge = wrfhydro.get_value(                                 â”‚
â”‚          "channel_water__volume_flow_rate")                           â”‚
â”‚                                                                      â”‚
â”‚      # Pass to SCHISM (PyMT handles grid mapping!)                   â”‚
â”‚      schism.set_value(                                               â”‚
â”‚          "channel_water__volume_flow_rate", discharge)                â”‚
â”‚                                                                      â”‚
â”‚      # Advance SCHISM by 1 hour (~36 internal steps)                 â”‚
â”‚      schism.update_until(target_time)                                â”‚
â”‚                                                                      â”‚
â”‚      # Get water levels from SCHISM                                  â”‚
â”‚      water_level = schism.get_value(                                 â”‚
â”‚          "sea_water_surface__elevation")                              â”‚
â”‚                                                                      â”‚
â”‚      # Pass back to WRF-Hydro (coastal boundary condition)           â”‚
â”‚      wrfhydro.set_value(                                             â”‚
â”‚          "sea_water_surface__elevation", water_level)                 â”‚
â”‚                                                                      â”‚
â”‚  # Cleanup                                                           â”‚
â”‚  wrfhydro.finalize()                                                 â”‚
â”‚  schism.finalize()                                                   â”‚
â”‚                                                                      â”‚
â”‚  THAT'S IT. Compound flooding simulation in ~20 lines of Python!     â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 8ï¸âƒ£ PyMT Model Properties & Methods

### ğŸ“Š What You Can Do With a PyMT Model

Once a model is loaded in PyMT, it exposes these properties and methods:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚  LIFECYCLE METHODS                                                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                  â”‚
â”‚  model.setup()                  Get default config                   â”‚
â”‚  model.initialize(config)       Start the model                      â”‚
â”‚  model.update()                 Advance one step                     â”‚
â”‚  model.update_until(time)       Advance to specific time             â”‚
â”‚  model.finalize()               Shut down                            â”‚
â”‚                                                                      â”‚
â”‚  DATA ACCESS                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚  model.get_value(name)          Get variable as NumPy array          â”‚
â”‚  model.set_value(name, array)   Set variable from NumPy array        â”‚
â”‚                                                                      â”‚
â”‚  INTROSPECTION PROPERTIES                                            â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                            â”‚
â”‚  model.input_var_names          List of input variable names         â”‚
â”‚  model.output_var_names         List of output variable names        â”‚
â”‚  model.time                     Current model time                   â”‚
â”‚  model.time_units               Time unit string (e.g., 'd')        â”‚
â”‚  model.time_step                Size of one time step                â”‚
â”‚  model.start_time               Simulation start time                â”‚
â”‚  model.end_time                 Simulation end time                  â”‚
â”‚                                                                      â”‚
â”‚  GRID ACCESS                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                         â”‚
â”‚  model.grid_type(id)            Grid type string                     â”‚
â”‚  model.grid_shape(id)           Grid dimensions                      â”‚
â”‚  model.grid_spacing(id)         Cell sizes                           â”‚
â”‚  model.grid_origin(id)          Grid origin point                    â”‚
â”‚  model.grid_x(id)               X coordinates                       â”‚
â”‚  model.grid_y(id)               Y coordinates                       â”‚
â”‚                                                                      â”‚
â”‚  PYMT EXTRAS (beyond raw BMI)                                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚  model.var["var_name"]          Access variable as xarray-like       â”‚
â”‚  model.var["var_name"].data     Get data values                      â”‚
â”‚  model.quick_plot(name)         Quick visualization                  â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 9ï¸âƒ£ Data Components

### ğŸ“‚ Datasets as BMI Models

A unique PyMT feature: **datasets can also be wrapped with BMI** and used as model components. These are called **Data Components**.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                      â”‚
â”‚  WHAT ARE DATA COMPONENTS?                                           â”‚
â”‚                                                                      â”‚
â”‚  Regular models:   Compute new values each time step                 â”‚
â”‚  Data components:  Serve existing data through BMI interface         â”‚
â”‚                                                                      â”‚
â”‚  Examples:                                                           â”‚
â”‚  â€¢ pymt_gridmet  â€” GridMET meteorological data (temp, precip, etc.) â”‚
â”‚  â€¢ pymt_geotiff  â€” GeoTIFF raster data access                      â”‚
â”‚  â€¢ pymt_era5     â€” ERA5 reanalysis data                             â”‚
â”‚                                                                      â”‚
â”‚  WHY IS THIS USEFUL?                                                 â”‚
â”‚  You can "couple" a data source with a model the same way            â”‚
â”‚  you couple two models â€” using get_value / set_value!                â”‚
â”‚                                                                      â”‚
â”‚  Example: Feed real precipitation data to WRF-Hydro:                 â”‚
â”‚  precip = gridmet.get_value("daily_precipitation")                   â”‚
â”‚  wrfhydro.set_value("atmosphere_water__precipitation...", precip)     â”‚
â”‚                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”Ÿ Installation & Setup

### ğŸ“¦ From the Official Quickstart

**Install PyMT:**
```
conda create -n pymt -c conda-forge python pymt
conda activate pymt
```

**Install with specific model plugins:**
```
conda install -c conda-forge pymt pymt_hydrotrend pymt_cem
```

**Verify installation:**
```python
>>> import pymt
>>> pymt.MODELS
{'Hydrotrend', 'Cem', 'Waves', ...}
```

**Requirements:**
- Python 3.8+
- conda (strongly recommended over pip)
- Anaconda or Miniconda distribution

---

## 1ï¸âƒ£1ï¸âƒ£ Where PyMT Fits in Our Project

### ğŸ—ï¸ The Full Stack

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                        â”‚
â”‚  LAYER 5 (TOP): SCIENTIST / JUPYTER NOTEBOOK                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚  The user writes Python code in Jupyter.                               â”‚
â”‚  Calls: wrfhydro.update(), schism.get_value(), etc.                   â”‚
â”‚                                                                        â”‚
â”‚  LAYER 4: PyMT FRAMEWORK  â† â˜… THIS GUIDE â˜…                          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  Orchestrates coupling: grid mappers, time steppers,                   â”‚
â”‚  data exchange, NetCDF output, Standard Names matching.                â”‚
â”‚                                                                        â”‚
â”‚  LAYER 3: BABELIZED PLUGINS                                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  pymt_wrfhydro and pymt_schism Python packages.                        â”‚
â”‚  Created by the Babelizer from the Fortran BMI wrappers.              â”‚
â”‚                                                                        â”‚
â”‚  LAYER 2: BMI WRAPPERS                                                â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                 â”‚
â”‚  bmi_wrf_hydro.f90 and bmischism.f90                                   â”‚
â”‚  The 41 BMI functions wrapping each model's internals.                 â”‚
â”‚                                                                        â”‚
â”‚  LAYER 1 (BOTTOM): ORIGINAL MODELS                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                      â”‚
â”‚  WRF-Hydro Fortran code (land/river hydrology)                         â”‚
â”‚  SCHISM Fortran code (coastal ocean dynamics)                          â”‚
â”‚  Running at FULL NATIVE SPEED â€” no performance penalty!               â”‚
â”‚                                                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1ï¸âƒ£2ï¸âƒ£ Key Takeaways

### ğŸ’ What You Need to Remember

1. **PyMT = The coupling framework** that sits on TOP of BMI and Babelizer
2. **Six pillars:** Grid mappers, time steppers, data exchange, auto-loading, standards, plugins
3. **Grid mapping is the hardest part** â€” interpolating between uniform_rectilinear (WRF-Hydro) and unstructured (SCHISM)
4. **Time synchronization** handles different step sizes (1hr vs 100s)
5. **Plugin system** â€” each babelized model becomes a PyMT plugin
6. **Data components** â€” even datasets can be coupled like models
7. **All from Python** â€” Jupyter Notebooks, scripts, interactive exploration
8. **Full native speed** â€” Fortran runs under the hood, Python just orchestrates
9. **Automatic extras:** NetCDF output, unit conversion, name matching
10. **Official example pattern:** `get_value â†’ transform â†’ set_value â†’ update` in a loop

---

## 1ï¸âƒ£3ï¸âƒ£ Key References

| Reference | Link |
|-----------|------|
| ğŸ“¦ PyMT GitHub | https://github.com/csdms/pymt |
| ğŸ“– PyMT Docs | https://pymt.readthedocs.io |
| ğŸŒ CSDMS Wiki: PyMT | https://csdms.colorado.edu/wiki/PyMT |
| ğŸš€ Quickstart Guide | https://pymt.readthedocs.io/en/latest/quickstart.html |
| ğŸ”Œ BMI Tools Page | https://bmi.csdms.io/en/latest/csdms.html |
| ğŸ“Š PyMT GitHub Pages | https://csdms.github.io/pymt/ |
| ğŸ Anaconda Package | https://anaconda.org/conda-forge/pymt |
| ğŸ§° CSDMS Workbench | https://csdms.colorado.edu/wiki/Workbench |
| ğŸ“„ Hutton et al. (2016) AGU | https://ui.adsabs.harvard.edu/abs/2016AGUFMEP43A0941H |
| ğŸŒ¡ï¸ Data Component: gridMET | https://pymt-gridmet.readthedocs.io |
| ğŸ—ºï¸ Data Component: GeoTiff | https://pymt-geotiff.readthedocs.io |
| ğŸ”® Babelizer (prerequisite) | https://github.com/csdms/babelizer |
| ğŸ’¬ CSDMS Help Desk | https://github.com/csdms/help-desk |

---

*Document based exclusively on official CSDMS documentation, GitHub repositories, ReadTheDocs, and published abstracts.*
*Prepared for WRF-Hydro / SCHISM coupling project context.*
