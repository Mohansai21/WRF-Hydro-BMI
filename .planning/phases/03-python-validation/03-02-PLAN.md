---
phase: 03-python-validation
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - bmi_wrf_hydro/tests/test_bmi_python.py
  - bmi_wrf_hydro/tests/conftest.py
autonomous: true
requirements: [PYTEST-01, PYTEST-02, PYTEST-03, PYTEST-04]

must_haves:
  truths:
    - "Python loads libbmiwrfhydrof.so via ctypes after RTLD_GLOBAL preloading of libmpi.so"
    - "Python completes full IRF cycle: register -> initialize -> update (6 hours) -> get_value -> finalize without segfault"
    - "Croton NY channel streamflow values retrieved via Python are physically valid (>= 0) and evolve over time"
    - "Grid sizes and array dimensions are queried dynamically from BMI functions, not hardcoded"
    - "Quick smoke test (1-2 timesteps) and full 6-hour validation both work from the same test infrastructure"
  artifacts:
    - path: "bmi_wrf_hydro/tests/test_bmi_python.py"
      provides: "pytest-based test exercising BMI lifecycle via ctypes with smoke and full markers"
      min_lines: 150
    - path: "bmi_wrf_hydro/tests/conftest.py"
      provides: "pytest fixtures for library loading, MPI preload, and BMI initialization"
      min_lines: 40
  key_links:
    - from: "bmi_wrf_hydro/tests/test_bmi_python.py"
      to: "libbmiwrfhydrof.so"
      via: "ctypes.CDLL loading"
      pattern: "ctypes\\.CDLL.*libbmiwrfhydrof"
    - from: "bmi_wrf_hydro/tests/conftest.py"
      to: "libmpi.so"
      via: "RTLD_GLOBAL preload"
      pattern: "RTLD_GLOBAL.*libmpi"
    - from: "bmi_wrf_hydro/tests/test_bmi_python.py"
      to: "bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90"
      via: "bind(C) symbols called through ctypes"
      pattern: "lib\\.bmi_"
---

<objective>
Create a pytest-based Python test that loads `libbmiwrfhydrof.so` via ctypes, exercises the full BMI lifecycle through the C binding layer, and validates Croton NY simulation results match the Fortran test suite.

Purpose: Proves the shared library works end-to-end from Python before handing it to the babelizer. This is the final validation that the `.so` is a viable building block for Phase 2 of the overall project (babelizer).

Output: `test_bmi_python.py` and `conftest.py` with two test modes (smoke: 1-2 timesteps, full: 6-hour validation), all passing.
</objective>

<execution_context>
@/home/mohansai/.claude/get-shit-done/workflows/execute-plan.md
@/home/mohansai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-python-validation/03-RESEARCH.md
@.planning/phases/03-python-validation/03-01-SUMMARY.md
@bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90
@bmi_wrf_hydro/tests/bmi_wrf_hydro_test.f90
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conftest.py with library loading and MPI preload fixtures</name>
  <files>bmi_wrf_hydro/tests/conftest.py</files>
  <action>
Create `bmi_wrf_hydro/tests/conftest.py` (~60-80 lines) with pytest fixtures for:

**1. pytest markers registration:**
Register `smoke` and `full` markers so pytest doesn't emit warnings:
```python
def pytest_configure(config):
    config.addinivalue_line("markers", "smoke: quick 1-2 timestep test")
    config.addinivalue_line("markers", "full: full 6-hour validation test")
```

**2. `libmpi` fixture (session scope):**
Preload `libmpi.so` with `RTLD_GLOBAL` to satisfy Open MPI's plugin system (PYTEST-03).
```python
@pytest.fixture(scope="session")
def libmpi():
    conda_prefix = os.environ.get("CONDA_PREFIX")
    if not conda_prefix:
        pytest.skip("CONDA_PREFIX not set -- activate wrfhydro-bmi env")
    libmpi_path = os.path.join(conda_prefix, "lib", "libmpi.so")
    mpi = ctypes.CDLL(libmpi_path, ctypes.RTLD_GLOBAL)
    return mpi
```

**3. `bmi_lib` fixture (session scope):**
Load `libbmiwrfhydrof.so` AFTER MPI preload. Set `restype = ctypes.c_int` for all 10 `bmi_*` functions. Also set `argtypes` for each function to enable type checking:
- `bmi_register`: no args
- `bmi_initialize`: `[ctypes.c_char_p]`
- `bmi_update`: no args
- `bmi_finalize`: no args
- `bmi_get_component_name`: `[ctypes.c_char_p, ctypes.c_int]`
- `bmi_get_current_time`: `[ctypes.POINTER(ctypes.c_double)]`
- `bmi_get_var_grid`: `[ctypes.c_char_p, ctypes.POINTER(ctypes.c_int)]`
- `bmi_get_grid_size`: `[ctypes.c_int, ctypes.POINTER(ctypes.c_int)]`
- `bmi_get_var_nbytes`: `[ctypes.c_char_p, ctypes.POINTER(ctypes.c_int)]`
- `bmi_get_value_double`: `[ctypes.c_char_p, ctypes.POINTER(ctypes.c_double)]`

**4. `bmi_config_file` fixture (session scope):**
Create a BMI config file with ABSOLUTE path to the Croton NY run directory. The config content must be:
```
&bmi_wrf_hydro_config
  wrfhydro_run_dir = "<absolute_path_to_WRF_Hydro_Run_Local/run>/"
/
```
Use `os.path.abspath` to compute the project root from `__file__` (conftest.py is in `bmi_wrf_hydro/tests/`, project root is 2 levels up). Write the config file to a temporary location using `tmp_path_factory` (session-scoped).

Important: The path MUST end with `/` (trailing slash) because WRF-Hydro's `trim(wrfhydro_run_dir)` expects it.

**5. `bmi_session` fixture (session scope):**
Performs the full register -> initialize -> yield -> finalize -> MPI_Finalize lifecycle:
```python
@pytest.fixture(scope="session")
def bmi_session(bmi_lib, libmpi, bmi_config_file):
    lib = bmi_lib
    # Register singleton
    status = lib.bmi_register()
    assert status == 0, f"bmi_register failed with status {status}"
    # Initialize with config file
    status = lib.bmi_initialize(bmi_config_file.encode())
    assert status == 0, f"bmi_initialize failed with status {status}"
    yield lib
    # Finalize BMI
    lib.bmi_finalize()
    # Finalize MPI (call directly on libmpi)
    ierr = ctypes.c_int()
    libmpi.MPI_Finalize(ctypes.byref(ierr))
```

Note: `bmi_config_file` returns the path as a string. `encode()` converts to bytes, and `ctypes.c_char_p` in argtypes handles null-termination automatically.

**Working directory:** The `bmi_session` fixture must `os.chdir()` to the `bmi_wrf_hydro/` directory before calling `bmi_initialize`, because the Fortran code may use relative paths internally. Save and restore the original cwd.

**Important design note about singleton + test ordering:** Since WRF-Hydro cannot be re-initialized within the same process (wrfhydro_engine_initialized flag), ALL tests share a single session. The smoke tests run first (testing init/component_name/time), then full tests continue from the same state (running 6 hours and validating). Tests must be designed to work in this sequential, single-init pattern.
  </action>
  <verify>
```bash
# File exists and has expected content:
test -f bmi_wrf_hydro/tests/conftest.py && echo "conftest.py exists"
grep -c "RTLD_GLOBAL" bmi_wrf_hydro/tests/conftest.py  # Should be >= 1
grep -c "bmi_register\|bmi_initialize\|bmi_finalize" bmi_wrf_hydro/tests/conftest.py  # Should be >= 3
grep -c "scope.*session" bmi_wrf_hydro/tests/conftest.py  # Should be >= 3
```
  </verify>
  <done>conftest.py exists with session-scoped fixtures for MPI preload, library loading, config file creation, and BMI lifecycle management.</done>
</task>

<task type="auto">
  <name>Task 2: Create test_bmi_python.py and run full validation</name>
  <files>bmi_wrf_hydro/tests/test_bmi_python.py</files>
  <action>
Create `bmi_wrf_hydro/tests/test_bmi_python.py` (~200-250 lines) with pytest tests covering both smoke and full modes.

**Constants:**
```python
BMI_SUCCESS = 0
BMI_FAILURE = 1
STREAMFLOW_VAR = b"channel_water__volume_flow_rate"
```

**Smoke tests (@pytest.mark.smoke):**

1. `test_register_singleton(bmi_session)` -- Verify that calling `bmi_register()` a second time returns `BMI_FAILURE` (singleton guard, CBIND-04). The `bmi_session` fixture already called register once. This must be the first test to run (use ordering or rely on file-level ordering).

2. `test_component_name(bmi_session)` -- Call `bmi_get_component_name(buf, 256)` and verify the returned string is `"WRF-Hydro BMI"` (matching the Fortran wrapper's component name). Use `ctypes.create_string_buffer(256)` for the buffer.

3. `test_initial_time(bmi_session)` -- Call `bmi_get_current_time` and verify the initial time is 0.0 (before any updates). Use `ctypes.c_double()` and `ctypes.byref()`.

4. `test_smoke_update_and_time(bmi_session)` -- Call `bmi_update()` once, then `bmi_get_current_time()` and verify time > 0.0 (time advanced). This is the "1-2 timestep" smoke test per user decision.

5. `test_smoke_get_grid_size_dynamic(bmi_session)` -- Query grid size for streamflow variable dynamically (PYTEST-04): call `bmi_get_var_grid(STREAMFLOW_VAR, &grid_id)`, then `bmi_get_grid_size(grid_id, &size)`, verify `size > 0`. Also call `bmi_get_var_nbytes(STREAMFLOW_VAR, &nbytes)` and verify `nbytes > 0` and `nbytes == size * 8` (double precision = 8 bytes).

6. `test_smoke_get_streamflow(bmi_session)` -- After 1 update (from test 4), get streamflow values dynamically: query grid size, allocate `numpy.zeros(size, dtype=numpy.float64)`, call `bmi_get_value_double`, verify at least some values are >= 0 (physical validity check).

**Full tests (@pytest.mark.full):**

7. `test_full_6hour_streamflow_evolution(bmi_session)` -- This is the main PYTEST-02 validation:
   - Capture streamflow values at current state (already 1 step in from smoke tests)
   - Store as `step1_values = values.copy()`
   - Run 5 more `bmi_update()` calls (total = 6 timesteps = 6 hours for hourly stepping)
   - Capture streamflow again as `step6_values`
   - Validate:
     a. Physical validity: `numpy.any(step6_values >= 0.0)` (some channels have flow)
     b. Evolution: `numpy.any(numpy.abs(step1_values - step6_values) > 1e-15)` (values changed, matching Fortran test tolerance)
     c. Range check: print min/max of step1 and step6 for inspection
   - Dynamic grid size query (PYTEST-04): all array allocations use queried sizes, zero hardcoded dimensions

8. `test_full_streamflow_physical_range(bmi_session)` -- After 6 hours, verify streamflow values are in a physically plausible range for Croton NY:
   - All values >= 0 (no negative streamflow)
   - Max value < 1e6 m3/s (sanity check -- Croton is a small watershed, Hurricane Irene peak was ~hundreds of m3/s)
   - At least one non-zero value (model is producing output)

**Test execution order:**
Tests within a file execute top-to-bottom by default in pytest. Since all tests share a single `bmi_session`, order matters:
- Smoke tests run first (test_register_singleton, test_component_name, test_initial_time, test_smoke_update_and_time, test_smoke_get_grid_size_dynamic, test_smoke_get_streamflow)
- Full tests run after (test_full_6hour_streamflow_evolution, test_full_streamflow_physical_range)
- The session fixture handles init at start and finalize at end

**Run commands (document at top of file in docstring):**
```bash
# Activate conda env first:
# source ~/miniconda3/etc/profile.d/conda.sh && conda activate wrfhydro-bmi

# Quick smoke test (1-2 timesteps, ~30s):
# cd bmi_wrf_hydro && python -m pytest tests/test_bmi_python.py -m smoke -v

# Full 6-hour validation (~2-3 min):
# cd bmi_wrf_hydro && python -m pytest tests/test_bmi_python.py -v

# Note: All tests share a single BMI session (WRF-Hydro singleton).
# Running smoke-only skips the 6-hour simulation.
# Running all tests includes both smoke and full.
```

**After creating the file, run the full test suite:**
```bash
cd /mnt/c/Users/mohansai/Desktop/Projects/VS_Code/WRF-Hydro-BMI/bmi_wrf_hydro
source ~/miniconda3/etc/profile.d/conda.sh && conda activate wrfhydro-bmi
python -m pytest tests/test_bmi_python.py -v 2>&1
```

If the test fails:
- MPI segfault: verify RTLD_GLOBAL preload order in conftest.py
- String errors: verify null termination in ctypes calls
- Wrong directory: verify os.chdir to bmi_wrf_hydro/ before initialize
- Import errors: verify numpy and pytest are in conda env

If `python -m pytest` fails due to MPI singleton init, try:
```bash
mpirun --oversubscribe -np 1 python -m pytest tests/test_bmi_python.py -v
```
And document whichever launch method works.

**Tolerance guidance:** Use `1e-6` for any REAL-to-double comparisons, `1e-15` for double-to-double evolution checks (matching the Fortran test suite).
  </action>
  <verify>
```bash
cd /mnt/c/Users/mohansai/Desktop/Projects/VS_Code/WRF-Hydro-BMI/bmi_wrf_hydro
source ~/miniconda3/etc/profile.d/conda.sh && conda activate wrfhydro-bmi
# Run all tests (smoke + full):
python -m pytest tests/test_bmi_python.py -v 2>&1 | tail -20
# Expected: all tests pass (8 passed)
# If MPI needs mpirun:
# mpirun --oversubscribe -np 1 python -m pytest tests/test_bmi_python.py -v 2>&1 | tail -20
```
  </verify>
  <done>test_bmi_python.py has 8 tests (6 smoke, 2 full) all passing. Python successfully loads libbmiwrfhydrof.so, exercises BMI lifecycle, and validates Croton NY streamflow. Grid sizes are queried dynamically. Both smoke and full modes work from the same infrastructure.</done>
</task>

</tasks>

<verification>
1. `python -m pytest bmi_wrf_hydro/tests/test_bmi_python.py -v` -- all 8 tests pass
2. Smoke tests complete in ~30s, full tests in ~2-3 min
3. Streamflow values are physically valid (>= 0, evolve over time)
4. No hardcoded Croton NY dimensions in test code (all dynamic via get_grid_size/get_var_nbytes)
5. MPI handled via RTLD_GLOBAL preload without segfault
6. Singleton guard returns BMI_FAILURE on second register call
</verification>

<success_criteria>
- All 8 Python tests pass (6 smoke + 2 full)
- Python ctypes successfully loads libbmiwrfhydrof.so and calls all 10 C binding functions
- Croton NY streamflow values retrieved from Python match Fortran test suite validation criteria
- No MPI segfaults or initialization conflicts
- Grid metadata queried dynamically (PYTEST-04)
</success_criteria>

<output>
After completion, create `.planning/phases/03-python-validation/03-02-SUMMARY.md`
</output>
