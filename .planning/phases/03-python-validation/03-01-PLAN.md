---
phase: 03-python-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90
  - bmi_wrf_hydro/CMakeLists.txt
  - bmi_wrf_hydro/build.sh
autonomous: true
requirements: [CBIND-01, CBIND-03, CBIND-04]

must_haves:
  truths:
    - "libbmiwrfhydrof.so exports flat C symbols (bmi_register, bmi_initialize, bmi_update, bmi_finalize, bmi_get_component_name, bmi_get_current_time, bmi_get_var_grid, bmi_get_grid_size, bmi_get_var_nbytes, bmi_get_value_double) visible via nm -D"
    - "Calling bmi_register a second time returns BMI_FAILURE (singleton guard)"
    - "String conversion helpers correctly handle null-terminated C strings to/from Fortran character arrays"
    - "Existing 151-test Fortran suite still passes after adding the C binding source to the build"
  artifacts:
    - path: "bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90"
      provides: "Minimal C binding module with bind(C) wrappers for 10 BMI functions + string helpers"
      min_lines: 100
    - path: "bmi_wrf_hydro/CMakeLists.txt"
      provides: "Updated to compile bmi_wrf_hydro_c.f90 into libbmiwrfhydrof.so"
      contains: "bmi_wrf_hydro_c.f90"
    - path: "bmi_wrf_hydro/build.sh"
      provides: "Updated to compile bmi_wrf_hydro_c.f90 in both static and shared modes"
      contains: "bmi_wrf_hydro_c"
  key_links:
    - from: "bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90"
      to: "bmi_wrf_hydro/src/bmi_wrf_hydro.f90"
      via: "use bmiwrfhydrof, only: bmi_wrf_hydro"
      pattern: "use bmiwrfhydrof"
    - from: "bmi_wrf_hydro/CMakeLists.txt"
      to: "bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90"
      via: "add_library source list"
      pattern: "bmi_wrf_hydro_c\\.f90"
---

<objective>
Create the minimal C binding layer (`bmi_wrf_hydro_c.f90`) that exposes 10 key BMI functions as flat `bind(C)` symbols callable from Python ctypes, then update both build systems (CMake and build.sh) to compile it into `libbmiwrfhydrof.so`.

Purpose: The shared library currently only exports Fortran module-mangled symbols (e.g., `__bmiwrfhydrof_MOD_wrfhydro_initialize`) which are not callable from C or Python. This plan adds a thin C interop layer that exposes clean C symbols (e.g., `bmi_initialize`) for Python ctypes to call. This is test infrastructure -- the babelizer auto-generates the full 818-line interop layer for production.

Output: `bmi_wrf_hydro_c.f90` compiled into the `.so`, 10 `bmi_*` symbols exported, singleton guard working, 151-test regression passing.
</objective>

<execution_context>
@/home/mohansai/.claude/get-shit-done/workflows/execute-plan.md
@/home/mohansai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-python-validation/03-RESEARCH.md
@.planning/phases/02-shared-library-install/02-02-SUMMARY.md
@bmi_wrf_hydro/src/bmi_wrf_hydro.f90
@bmi_wrf_hydro/CMakeLists.txt
@bmi_wrf_hydro/build.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bmi_wrf_hydro_c.f90 with bind(C) wrappers and string helpers</name>
  <files>bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90</files>
  <action>
Create `bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90` (~150-200 lines) implementing the minimal C binding layer as a Fortran module. Follow the singleton pattern from research (NOT the box/opaque-handle pattern).

**Module structure:**
```
module bmi_wrf_hydro_c_mod
  use bmiwrfhydrof, only: bmi_wrf_hydro
  use bmif_2_0, only: BMI_SUCCESS, BMI_FAILURE, BMI_MAX_COMPONENT_NAME
  use, intrinsic :: iso_c_binding
  implicit none
  private

  type(bmi_wrf_hydro), save, target :: the_model
  logical, save :: is_registered = .false.

contains
  ! String helpers + 10 bind(C) functions
end module
```

**String helpers (CBIND-03):**
1. `c_to_f_string(c_string)` -- pure function, converts assumed-size `character(kind=c_char,len=1) :: c_string(*)` to allocatable Fortran string by scanning for `c_null_char`. Use character assignment in a do loop (NOT `transfer` -- it can produce incorrect results with some compilers for character arrays).
2. `f_to_c_string(f_string, c_string, c_len)` -- subroutine that copies trimmed Fortran string into a pre-allocated `c_char` array and appends `c_null_char`. Takes the buffer length as an argument to prevent overflow.

**10 bind(C) functions (CBIND-01):**
1. `bmi_register()` -> singleton guard (CBIND-04): sets `is_registered = .true.` on first call, returns `BMI_FAILURE` on subsequent calls. No model allocation needed since `the_model` is module-level SAVE.
2. `bmi_initialize(config_file)` -> calls `the_model%initialize(f_file)` after converting C string. Config file is `character(kind=c_char), intent(in) :: config_file(*)`.
3. `bmi_update()` -> calls `the_model%update()`. No arguments.
4. `bmi_finalize()` -> calls `the_model%finalize()`. Resets `is_registered = .false.` so the singleton can be reused in a future process (though WRF-Hydro itself prevents re-init via `wrfhydro_engine_initialized`).
5. `bmi_get_component_name(name, n)` -> calls `the_model%get_component_name(f_name)`, then copies result into caller-provided `character(kind=c_char) :: name(n)` buffer using `f_to_c_string`. The `n` parameter is `integer(c_int), value` specifying buffer size.
6. `bmi_get_current_time(time)` -> calls `the_model%get_current_time(time)`. Output is `real(c_double), intent(out) :: time`.
7. `bmi_get_var_grid(name, grid)` -> calls `the_model%get_var_grid(f_name, grid)` after converting variable name string. Output is `integer(c_int), intent(out) :: grid`.
8. `bmi_get_grid_size(grid, size)` -> calls `the_model%get_grid_size(grid, size)`. Grid ID is `integer(c_int), value, intent(in) :: grid`. Output is `integer(c_int), intent(out) :: size`.
9. `bmi_get_var_nbytes(name, nbytes)` -> calls `the_model%get_var_nbytes(f_name, nbytes)` after converting name. Output is `integer(c_int), intent(out) :: nbytes`.
10. `bmi_get_value_double(name, dest)` -> calls `the_model%get_var_nbytes` and `the_model%get_var_itemsize` to determine array length, then calls `the_model%get_value_double(f_name, dest(1:n_items))`. Dest is `real(c_double), intent(out) :: dest(*)`.

**Important details:**
- All functions return `integer(c_int)` as the result (BMI_SUCCESS=0 or BMI_FAILURE=1).
- The `c_to_f_string` function MUST handle the assumed-size array correctly -- use a `do while` loop to find the null terminator, then allocate and copy character by character.
- For `bmi_get_component_name`, the BMI wrapper's `get_component_name` returns a pointer to an internal character variable. Use `f_to_c_string` to copy the trimmed content into the output buffer.
- Do NOT use `intent(in)` on assumed-size `c_char` arrays in `bind(C)` functions for the `c_to_f_string` helper -- gfortran allows it but some compilers require it to be a separate pure function.
- Follow the exact code patterns from 03-RESEARCH.md "Complete C Binding Module" section, adapting as needed for the `f_to_c_string` signature (use subroutine with buffer length, not function returning array, to avoid stack issues).
  </action>
  <verify>
Verify the file compiles standalone (syntax check):
```bash
cd /mnt/c/Users/mohansai/Desktop/Projects/VS_Code/WRF-Hydro-BMI/bmi_wrf_hydro
source ~/miniconda3/etc/profile.d/conda.sh && conda activate wrfhydro-bmi
gfortran -c -fsyntax-only -ffree-form -ffree-line-length-none src/bmi_wrf_hydro_c.f90 -I${CONDA_PREFIX}/include -I../wrf_hydro_nwm_public/build_fpic/mods -Ibuild/ 2>&1 || echo "Syntax check requires .mod files from full build"
```
Count functions: `grep -c "bind(C" src/bmi_wrf_hydro_c.f90` should return 10.
Count string helpers: `grep -c "function c_to_f_string\|subroutine f_to_c_string" src/bmi_wrf_hydro_c.f90` should return 2.
Verify singleton guard: `grep "is_registered" src/bmi_wrf_hydro_c.f90` should show the guard logic.
  </verify>
  <done>bmi_wrf_hydro_c.f90 exists with 10 bind(C) functions, 2 string helpers, and singleton guard pattern. File is >= 100 lines.</done>
</task>

<task type="auto">
  <name>Task 2: Update build systems and verify C symbols in .so</name>
  <files>bmi_wrf_hydro/CMakeLists.txt, bmi_wrf_hydro/build.sh</files>
  <action>
Update both CMakeLists.txt and build.sh to compile `bmi_wrf_hydro_c.f90` into `libbmiwrfhydrof.so`, then rebuild, reinstall, and verify.

**CMakeLists.txt changes (SECTION 7):**
Add `src/bmi_wrf_hydro_c.f90` to the `add_library(${bmi_name} SHARED ...)` source list, right after `src/bmi_wrf_hydro.f90`. The file depends on the `bmiwrfhydrof` module (from `bmi_wrf_hydro.f90`), and CMake handles Fortran module dependencies automatically within the same target.

Also add the `bmi_wrf_hydro_c_mod.mod` file to the install section (SECTION 10), following the same pattern as the existing `.mod` installs:
```cmake
install(
  FILES ${CMAKE_Fortran_MODULE_DIRECTORY}/bmi_wrf_hydro_c_mod.mod
  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)
```

**build.sh changes:**
In the compilation step (after compiling `bmi_wrf_hydro.f90`), add compilation of `bmi_wrf_hydro_c.f90`:
```bash
gfortran -c -cpp -DWRF_HYDRO -DMPP_LAND \
  -ffree-form -ffree-line-length-none -fPIC \
  -fconvert=big-endian -frecord-marker=4 \
  -fallow-argument-mismatch \
  -I${CONDA_PREFIX}/include \
  -I${WRF_MOD_DIR} \
  -I${BUILD_DIR} \
  src/bmi_wrf_hydro_c.f90 \
  -o ${BUILD_DIR}/bmi_wrf_hydro_c.o
```
This must come AFTER `bmi_wrf_hydro.f90` compilation (it depends on `bmiwrfhydrof.mod`).

In the shared library link step (`gfortran -shared`), add `${BUILD_DIR}/bmi_wrf_hydro_c.o` to the object file list.

In the static link step (for test executables without --shared), add `${BUILD_DIR}/bmi_wrf_hydro_c.o` to the object files linked into executables.

**After updating both files, execute the full verification sequence:**

1. Build via build.sh --shared and verify 151/151 tests pass:
```bash
cd /mnt/c/Users/mohansai/Desktop/Projects/VS_Code/WRF-Hydro-BMI/bmi_wrf_hydro
./build.sh --shared full
```

2. Verify C symbols exported from the .so:
```bash
nm -D build/libbmiwrfhydrof.so | grep "T bmi_"
```
Expected: 10 symbols (bmi_register, bmi_initialize, bmi_update, bmi_finalize, bmi_get_component_name, bmi_get_current_time, bmi_get_var_grid, bmi_get_grid_size, bmi_get_var_nbytes, bmi_get_value_double).

3. Rebuild and reinstall via CMake:
```bash
cd /mnt/c/Users/mohansai/Desktop/Projects/VS_Code/WRF-Hydro-BMI/bmi_wrf_hydro
cmake -B _build -DCMAKE_INSTALL_PREFIX=$CONDA_PREFIX
cmake --build _build
cmake --install _build
```

4. Verify installed .so has C symbols:
```bash
nm -D $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep "T bmi_"
```

5. Verify installed .mod file:
```bash
ls $CONDA_PREFIX/include/bmi_wrf_hydro_c_mod.mod
```

6. Verify no unresolved symbols:
```bash
ldd $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep "not found"
```
Expected: no output (all dependencies resolved).
  </action>
  <verify>
```bash
# All must succeed:
# 1. build.sh --shared full -> 151/151 tests pass (check output for "PASS: 151")
# 2. nm -D build/libbmiwrfhydrof.so | grep -c "T bmi_" -> should be >= 10
# 3. nm -D $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep -c "T bmi_" -> should be >= 10
# 4. ldd $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep "not found" -> no output
# 5. ls $CONDA_PREFIX/include/bmi_wrf_hydro_c_mod.mod -> file exists
```
  </verify>
  <done>Both build systems compile bmi_wrf_hydro_c.f90 into libbmiwrfhydrof.so. 10 bmi_* C symbols are exported from the installed .so. 151/151 Fortran tests still pass. No unresolved symbols.</done>
</task>

</tasks>

<verification>
1. `bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90` exists with >= 100 lines
2. `grep -c "bind(C" bmi_wrf_hydro/src/bmi_wrf_hydro_c.f90` returns 10
3. `nm -D $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep -c "T bmi_"` returns >= 10
4. `ldd $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep "not found"` returns empty
5. 151/151 Fortran BMI tests pass (no regression from adding C binding)
</verification>

<success_criteria>
- bmi_wrf_hydro_c.f90 implements 10 bind(C) functions with singleton guard and string helpers
- Both build.sh --shared and CMake produce a .so with flat C symbols
- The installed .so at $CONDA_PREFIX/lib/ has all 10 bmi_* symbols
- No regression: 151/151 Fortran tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-python-validation/03-01-SUMMARY.md`
</output>
