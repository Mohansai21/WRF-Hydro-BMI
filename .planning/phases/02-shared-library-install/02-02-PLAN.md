---
phase: 02-shared-library-install
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bmi_wrf_hydro/CMakeLists.txt
  - bmi_wrf_hydro/bmiwrfhydrof.pc.cmake
  - .gitignore
autonomous: true
requirements: [BUILD-02, BUILD-04, BUILD-05]

must_haves:
  truths:
    - "`cmake --build _build` produces `libbmiwrfhydrof.so` with zero unresolved symbols"
    - "`cmake --install _build` places .so in `$CONDA_PREFIX/lib/`, .mod files in `$CONDA_PREFIX/include/`, and .pc in `$CONDA_PREFIX/lib/pkgconfig/`"
    - "`pkg-config --libs bmiwrfhydrof` returns valid linker flags including `-lbmiwrfhydrof`"
    - "`pkg-config --cflags bmiwrfhydrof` returns include path with `-I.../include`"
    - "`ldd $CONDA_PREFIX/lib/libbmiwrfhydrof.so` shows no 'not found' entries"
  artifacts:
    - path: "bmi_wrf_hydro/CMakeLists.txt"
      provides: "CMake project that builds libbmiwrfhydrof.so, installs it, and generates pkg-config"
      contains: "add_library(bmiwrfhydrof SHARED"
    - path: "bmi_wrf_hydro/bmiwrfhydrof.pc.cmake"
      provides: "pkg-config template for babelizer discovery"
      contains: "Requires:"
    - path: "$CONDA_PREFIX/lib/libbmiwrfhydrof.so"
      provides: "Installed shared library"
    - path: "$CONDA_PREFIX/include/bmiwrfhydrof.mod"
      provides: "Installed BMI wrapper Fortran module"
    - path: "$CONDA_PREFIX/include/wrfhydro_bmi_state_mod.mod"
      provides: "Installed BMI state module"
    - path: "$CONDA_PREFIX/lib/pkgconfig/bmiwrfhydrof.pc"
      provides: "pkg-config file for babelizer Meson build discovery"
  key_links:
    - from: "bmi_wrf_hydro/CMakeLists.txt"
      to: "bmi-fortran conda package"
      via: "pkg_check_modules(BMIF REQUIRED IMPORTED_TARGET bmif)"
      pattern: "pkg_check_modules.*BMIF.*bmif"
    - from: "bmi_wrf_hydro/CMakeLists.txt"
      to: "wrf_hydro_nwm_public/build_fpic/lib/*.a"
      via: "target_link_libraries with --whole-archive"
      pattern: "whole-archive"
    - from: "bmi_wrf_hydro/bmiwrfhydrof.pc.cmake"
      to: "babelizer Meson build"
      via: "pkg-config dependency discovery"
      pattern: "Requires:.*bmif"
---

<objective>
Create a CMake project that builds `libbmiwrfhydrof.so`, installs it to `$CONDA_PREFIX` with `.mod` files and a `.pc` pkg-config file, enabling the babelizer to discover the library.

Purpose: CMake is the install/packaging path. The babelizer's Meson build uses `pkg-config bmiwrfhydrof` to find the library. This plan creates the infrastructure that makes WRF-Hydro BMI babelizer-ready.

Output: `CMakeLists.txt`, `bmiwrfhydrof.pc.cmake`, installed shared library in conda prefix, verified pkg-config discovery.
</objective>

<execution_context>
@/home/mohansai/.claude/get-shit-done/workflows/execute-plan.md
@/home/mohansai/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fpic-foundation/01-01-SUMMARY.md
@bmi-example-fortran/CMakeLists.txt
@bmi-example-fortran/bmi_heat/CMakeLists.txt
@bmi-example-fortran/bmi_heat/bmiheatf.pc.cmake
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CMakeLists.txt and pkg-config template</name>
  <files>bmi_wrf_hydro/CMakeLists.txt, bmi_wrf_hydro/bmiwrfhydrof.pc.cmake, .gitignore</files>
  <action>
Create two new files following the bmi-example-fortran reference pattern.

**File 1: `bmi_wrf_hydro/CMakeLists.txt`**

Follow bmi-example-fortran's structure closely for babelizer compatibility. Single top-level CMakeLists.txt (no subdirectories needed since we don't build a separate model library):

```
cmake_minimum_required(VERSION 3.12)

project(bmi-wrf-hydro
  VERSION 1.0.0
  LANGUAGES Fortran
)

include(GNUInstallDirs)

set(bmi_name bmiwrfhydrof)
```

1. **Find dependencies:**
   - `find_package(PkgConfig REQUIRED)` then `pkg_check_modules(BMIF REQUIRED IMPORTED_TARGET bmif)` — exactly like bmi-example-fortran
   - `find_package(MPI REQUIRED COMPONENTS Fortran)` — for MPI linking
   - `include_directories(${BMIF_INCLUDE_DIRS})`
   - `set(CMAKE_Fortran_MODULE_DIRECTORY ${CMAKE_BINARY_DIR}/mod)` — for .mod output

2. **Locate WRF-Hydro fPIC libraries:**
   - Define `WRF_HYDRO_BUILD_DIR` as a cache variable defaulting to `${CMAKE_CURRENT_SOURCE_DIR}/../wrf_hydro_nwm_public/build_fpic`
   - Check it exists with `if(NOT EXISTS ${WRF_HYDRO_BUILD_DIR})` and `message(FATAL_ERROR ...)`
   - Set `WRF_LIB_DIR` = `${WRF_HYDRO_BUILD_DIR}/lib`
   - Set `WRF_MOD_DIR` = `${WRF_HYDRO_BUILD_DIR}/mods`
   - Set `WRF_OBJ_DIR` = `${WRF_HYDRO_BUILD_DIR}/src/CMakeFiles/wrfhydro.dir/Land_models/NoahMP/IO_code`
   - `include_directories(${WRF_MOD_DIR})` — for WRF-Hydro module files

3. **Collect WRF-Hydro static libraries:**
   - Use `file(GLOB WRF_STATIC_LIBS "${WRF_LIB_DIR}/*.a")` to find all 22 .a files
   - Verify count: `list(LENGTH WRF_STATIC_LIBS wrf_lib_count)` then `message(STATUS "Found ${wrf_lib_count} WRF-Hydro static libraries")`

4. **Add preprocessor definitions:**
   - `add_definitions(-DWRF_HYDRO -DMPP_LAND)` — same CPP flags as build.sh

5. **Create shared library:**
   ```cmake
   add_library(${bmi_name} SHARED src/bmi_wrf_hydro.f90)
   ```

6. **Link dependencies:**
   ```cmake
   target_link_libraries(${bmi_name}
     ${WRF_OBJ_DIR}/module_NoahMP_hrldas_driver.F.o
     ${WRF_OBJ_DIR}/module_hrldas_netcdf_io.F.o
     -Wl,--whole-archive
     ${WRF_STATIC_LIBS}
     -Wl,--no-whole-archive
     ${BMIF_LINK_LIBRARIES}
     MPI::MPI_Fortran
     -lnetcdff
     -lnetcdf
   )
   ```
   Note: `--whole-archive` is needed to pull ALL symbols from static libs into the shared lib (same reason as build.sh).

7. **Install targets** (matching bmi-example-fortran exactly):
   ```cmake
   install(TARGETS ${bmi_name}
     LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
     ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
     RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
   )
   install(
     FILES ${CMAKE_Fortran_MODULE_DIRECTORY}/${bmi_name}.mod
     DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
   )
   install(
     FILES ${CMAKE_Fortran_MODULE_DIRECTORY}/wrfhydro_bmi_state_mod.mod
     DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
   )
   install(
     FILES ${CMAKE_CURRENT_BINARY_DIR}/${bmi_name}.pc
     DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig
   )
   ```
   Note: We install TWO .mod files (bmiwrfhydrof.mod + wrfhydro_bmi_state_mod.mod), unlike bmi-example-fortran which has only one.

8. **Configure pkg-config file:**
   ```cmake
   configure_file(
     ${CMAKE_CURRENT_SOURCE_DIR}/${bmi_name}.pc.cmake
     ${CMAKE_CURRENT_BINARY_DIR}/${bmi_name}.pc
     @ONLY
   )
   ```

**File 2: `bmi_wrf_hydro/bmiwrfhydrof.pc.cmake`**

Follow the bmi-example-fortran pattern:
```
prefix=@CMAKE_INSTALL_PREFIX@
exec_prefix=${prefix}
libdir=${exec_prefix}/lib
includedir=${prefix}/include

Name: @bmi_name@
Description: BMI for WRF-Hydro hydrological model
Version: @CMAKE_PROJECT_VERSION@
Requires: bmif
Libs: -L${libdir} -l@bmi_name@
Cflags: -I${includedir}
```

Note: `Requires: bmif` (not `heatf, bmif` like the reference) because we don't have a separate WRF-Hydro model .pc file — the model's static libs are baked into our .so.

**File 3: `.gitignore` update**

Add `_build/` pattern to .gitignore (CMake build directory, following bmi-example-fortran convention). Add it near the existing `build_fpic/` entry.
  </action>
  <verify>
1. File exists: `ls bmi_wrf_hydro/CMakeLists.txt bmi_wrf_hydro/bmiwrfhydrof.pc.cmake`
2. CMake pattern check: `grep "add_library(bmiwrfhydrof SHARED" bmi_wrf_hydro/CMakeLists.txt`
3. pkg-config template check: `grep "Requires:" bmi_wrf_hydro/bmiwrfhydrof.pc.cmake`
4. .gitignore check: `grep "_build" .gitignore`
  </verify>
  <done>
CMakeLists.txt and bmiwrfhydrof.pc.cmake exist with correct structure following bmi-example-fortran pattern. .gitignore updated for _build/.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build, install, and verify shared library via CMake</name>
  <files>bmi_wrf_hydro/CMakeLists.txt</files>
  <action>
Execute the CMake build, install, and verification pipeline. All commands run from the `bmi_wrf_hydro/` directory.

1. **Configure CMake** (from bmi_wrf_hydro/ directory):
   ```bash
   source ~/miniconda3/etc/profile.d/conda.sh && conda activate wrfhydro-bmi
   cmake -B _build -DCMAKE_INSTALL_PREFIX=$CONDA_PREFIX
   ```
   Verify: cmake output shows "Found bmif", "Found MPI", correct WRF-Hydro library count (22).

2. **Build shared library:**
   ```bash
   cmake --build _build
   ```
   Verify: `ls _build/libbmiwrfhydrof.so` exists (or the cmake-generated name).

3. **Check for unresolved symbols:**
   ```bash
   ldd _build/libbmiwrfhydrof.so | grep "not found"
   ```
   Must return empty (no missing dependencies).

4. **Install to conda prefix:**
   ```bash
   cmake --install _build
   ```
   Verify all 4 artifacts installed:
   - `ls $CONDA_PREFIX/lib/libbmiwrfhydrof.so`
   - `ls $CONDA_PREFIX/include/bmiwrfhydrof.mod`
   - `ls $CONDA_PREFIX/include/wrfhydro_bmi_state_mod.mod`
   - `ls $CONDA_PREFIX/lib/pkgconfig/bmiwrfhydrof.pc`

5. **Verify pkg-config discovery:**
   ```bash
   pkg-config --libs bmiwrfhydrof
   pkg-config --cflags bmiwrfhydrof
   pkg-config --modversion bmiwrfhydrof
   ```
   - `--libs` must include `-lbmiwrfhydrof`
   - `--cflags` must include `-I.../include`
   - `--modversion` must return `1.0.0`

6. **Verify installed .so has no missing deps:**
   ```bash
   ldd $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep "not found"
   ```
   Must return empty.

7. **Verify BMI symbols are exported:**
   ```bash
   nm -D $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep -ci bmi
   ```
   Must return non-zero count.

**If cmake --build fails** with linker errors:
- Check if `--whole-archive` is causing issues. Try `--start-group/--end-group` as fallback.
- Check if MPI symbols are unresolved — may need explicit `-lmpi_mpifh -lmpi` flags.
- Check if the .o file paths are correct (build_fpic directory structure).
- If CMakeLists.txt needs fixes, update it and re-run cmake configure + build.

**If install fails** or pkg-config doesn't work:
- Check CMAKE_INSTALL_PREFIX was set correctly to $CONDA_PREFIX
- Check the .pc file content has correct paths
- Verify PKG_CONFIG_PATH includes $CONDA_PREFIX/lib/pkgconfig
  </action>
  <verify>
All 7 verification checks from the action must pass:
1. `cmake --build _build` succeeds
2. `ldd _build/libbmiwrfhydrof.so | grep "not found"` returns empty
3. `cmake --install _build` succeeds
4. All 4 artifacts exist in $CONDA_PREFIX
5. `pkg-config --libs bmiwrfhydrof` returns flags with `-lbmiwrfhydrof`
6. `ldd $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep "not found"` returns empty
7. `nm -D $CONDA_PREFIX/lib/libbmiwrfhydrof.so | grep -ci bmi` returns non-zero
  </verify>
  <done>
`libbmiwrfhydrof.so` is built, installed to `$CONDA_PREFIX`, discoverable via `pkg-config --libs bmiwrfhydrof`, has zero unresolved symbols, and exports BMI Fortran symbols.
  </done>
</task>

</tasks>

<verification>
1. **CMake build path:** `cmake -B _build && cmake --build _build` produces `libbmiwrfhydrof.so`
2. **Install path:** `cmake --install _build` places .so + 2 .mod files + .pc in correct conda prefix locations
3. **pkg-config discovery:** `pkg-config --libs bmiwrfhydrof` returns valid flags (babelizer will use this)
4. **No unresolved symbols:** `ldd` on both local and installed .so shows no "not found"
5. **BMI symbols exported:** `nm -D` shows BMI module symbols
</verification>

<success_criteria>
- CMake project follows bmi-example-fortran pattern for babelizer compatibility
- `libbmiwrfhydrof.so` builds and installs with no unresolved symbols
- pkg-config discovery works (the single requirement for babelizer to find the library)
- Both .mod files (bmiwrfhydrof.mod + wrfhydro_bmi_state_mod.mod) installed to include/
- .pc file correctly requires bmif dependency
</success_criteria>

<output>
After completion, create `.planning/phases/02-shared-library-install/02-02-SUMMARY.md`
</output>
